<?xml version="1.0"?>
<doc>
    <assembly>
        <name>/Users/dd/peach-slave/osx_release/build/slag/osx_release/Peach.Core/Peach.Core</name>
    </assembly>
    <members>
        <member name="T:Peach.Core.ActionException">
            <summary>
            Thrown when an error occurs in the action of a state model
            requiring the state model to exit.
            </summary>
            <remarks>
            This is not an error that will end fuzzing, instead we will exit
            the state model and continue to the next iteration.
            </remarks>
        </member>
        <member name="T:Peach.Core.Agent.Agent">
            <summary>
            Agent logic.  This class is typically
            called from the server side of agent channels.
            </summary>
        </member>
        <member name="P:Peach.Core.Agent.Agent.Monitors">
            <summary>
            Dictionary of currently loaded monitor instances.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Agent.QueryMonitors(System.String)">
            <summary>
            Send an information request (query) to all local monitors.
            </summary>
            <remarks>
            Monitors may expose information that other monitors can query.  For example a
            debugger monitor may expose a "QueryPid" to get the current process id.  This
            information could be useful to a window closing monitor that monitors windows created
            by the process id and closes them if needed.
            </remarks>
            <param name="query">Query to send to each monitor</param>
            <returns>Query response or null</returns>
        </member>
        <member name="T:Peach.Core.Agent.AgentClient">
            <summary>
            Abstract base class for all Agent servers.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.SupportedProtocol(System.String)">
            <summary>
            Does AgentServer instance support specified protocol?  For example, if
            the user supplies an agent URL of "http://....", than "http" is the protocol.
            </summary>
            <param name="protocol">Protocol to check</param>
            <returns>True if protocol is supported, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.AgentConnect(System.String,System.String,System.String)">
            <summary>
            Connect to agent
            </summary>
            <param name="name">Name of agent</param>
            <param name="url">Agent URL</param>
            <param name="password">Agent Password</param>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.AgentDisconnect">
            <summary>
            Disconnect from agent
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.CreatePublisher(System.String,Peach.Core.SerializableDictionary{System.String,Peach.Core.Variant})">
            <summary>
            Creates a publisher on the remote agent
            </summary>
            <param name="cls">Class of publisher to create</param>
            <param name="args">Arguments for publisher</param>
            <returns>Instance of remote publisher</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.StartMonitor(System.String,System.String,Peach.Core.SerializableDictionary{System.String,Peach.Core.Variant})">
            <summary>
            Start a specific monitor
            </summary>
            <param name="name">Name for monitor instance</param>
            <param name="cls">Class of monitor to start</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.StopMonitor(System.String)">
            <summary>
            Stop a specific monitor by name
            </summary>
            <param name="name">Name of monitor instance</param>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.StopAllMonitors">
            <summary>
            Stop all monitors currently running
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.SessionStarting">
            <summary>
            Starting a fuzzing session.  A session includes a number of test iterations.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.SessionFinished">
            <summary>
            Finished a fuzzing session.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.IterationStarting(System.UInt32,System.Boolean)">
            <summary>
            Starting a new iteration
            </summary>
            <param name="iterationCount">Iteration count</param>
            <param name="isReproduction">Are we re-running an iteration</param>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.IterationFinished">
            <summary>
            Iteration has completed.
            </summary>
            <returns>Returns true to indicate iteration should be re-run, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.DetectedFault">
            <summary>
            Was a fault detected during current iteration?
            </summary>
            <returns>True if a fault was detected, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.GetMonitorData">
            <summary>
            Get the fault information
            </summary>
            <returns>Returns array of Fault instances</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.MustStop">
            <summary>
            Can the fuzzing session continue, or must we stop?
            </summary>
            <returns>True if session must stop, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.AgentClient.Message(System.String,Peach.Core.Variant)">
            <summary>
            Send a message to all monitors.
            </summary>
            <param name="name">Message Name</param>
            <param name="data">Message data</param>
            <returns>Returns data as Variant or null.</returns>
        </member>
        <member name="T:Peach.Core.Agent.AgentManager">
            <summary>
            Manages all agents.  This includes
            full lifetime.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.IAgentServer">
            <summary>
            Agent Servers are required to implement this interface
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.AgentServerAttribute">
            <summary>
            Indicate class is an Agent Server.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.Channels.AgentServerLocal">
            <summary>
            This is an agent that runs in the local
            process, instead of a remote process.  This
            is much faster for things like file fuzzing.
            </summary>
        </member>
        <member name="F:Peach.Core.Agent.Channels.AgentClientTcpRemoting._restartAgent">
            <summary>
            This is set to true when fault data is collected
            indicating a fualt has occured.  When a fault occures
            the agent might get restarted or a virtual machine
            reset to a snapshot.
            </summary>
        </member>
        <member name="F:Peach.Core.Agent.Channels.AgentClientTcpRemoting._monitors">
            <summary>
            Contains information about all created monitors.
            </summary>
            <remarks>
            When restarting the agent connect we will need to recreate monitors.
            The tuple contains:
            * name
            * cls
            * args
            </remarks>
        </member>
        <member name="M:Peach.Core.Agent.Channels.AgentClientTcpRemoting.PerformRemoting(System.Threading.ThreadStart)">
            <summary>
            Perform our remoting call with a forced timeout.
            </summary>
            <param name="method">
            </param>
        </member>
        <member name="M:Peach.Core.Agent.Channels.AgentClientTcpRemoting.RecreateMonitors">
            <summary>
            This method is used to recreate monitors when we restart an agent connection.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.Channels.AgentServiceTcpRemote">
            <summary>
            Implement agent service running over XML-RPC.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.Channels.AgentServiceZeroMq">
            <summary>
            Implement agent service running over XML-RPC.
            </summary>
        </member>
        <member name="T:Peach.Core.Agent.Monitor">
            <summary>
            Monitors are hosted by agent processes and are
            able to report detected faults and gather information
            that is usefull when a fualt is detected.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.SessionStarting">
            <summary>
            Starting a fuzzing session.  A session includes a number of test iterations.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.SessionFinished">
            <summary>
            Finished a fuzzing session.
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.IterationStarting(System.UInt32,System.Boolean)">
            <summary>
            Starting a new iteration
            </summary>
            <param name="iterationCount">Iteration count</param>
            <param name="isReproduction">Are we re-running an iteration</param>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.IterationFinished">
            <summary>
            Iteration has completed.
            </summary>
            <returns>Returns true to indicate iteration should be re-run, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.DetectedFault">
            <summary>
            Was a fault detected during current iteration?
            </summary>
            <returns>True if a fault was detected, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.GetMonitorData">
            <summary>
            Return a Fault instance
            </summary>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.MustStop">
            <summary>
            Can the fuzzing session continue, or must we stop?
            </summary>
            <returns>True if session must stop, else false.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.Message(System.String,Peach.Core.Variant)">
            <summary>
            Send a message to the monitor and possibly get data back.
            </summary>
            <param name="name">Message name</param>
            <param name="data">Message data</param>
            <returns>Returns data or null.</returns>
        </member>
        <member name="M:Peach.Core.Agent.Monitor.ProcessQueryMonitors(System.String)">
            <summary>
            Process query from another monitor.
            </summary>
            <remarks>
            This method is used to respond to an information request
            from another monitor.  Debugger monitors may expose specific
            queryies such as "QueryPid" to get the running processes PID.
            </remarks>
            <param name="query">Query</param>
            <returns>Non-null response indicates query was handled.</returns>
        </member>
        <member name="T:Peach.Core.Agent.Monitors.CanaKitRelayMonitor">
            <summary>
            Cana Kit 4-port usb relay board.  This is a low cost board with
            4 relays that can be controlled over USB. By default this monitor will turn off then on
            a port of your choice when a fault is detected.  Optionally you can have
            the on/off occur before every iteration.
            </summary>
            <remarks>
            This monitor is used for embedded device fuzzing when you want to
            turn power or signal on/off while fuzzing.
            http://www.canakit.com/4-port-usb-relay-controller.html
            </remarks>
        </member>
        <member name="T:Peach.Core.Agent.Monitors.IpPower9258Monitor">
            <summary>
            IP Power 9258 is a network enabled power strip.  The power ports can be
            switched on/off via HTTP.  By default this monitor will turn off then on
            a port of your choice when a fault is detected.  Optionally you can have
            the on/off occur before every iteration.
            </summary>
            <remarks>
            http://www.opengear.com/product-ip-power-9258.html
            </remarks>
        </member>
        <member name="T:Peach.Core.Agent.Monitors.Process">
            <summary>
            Start a process
            </summary>
        </member>
        <member name="M:Peach.Core.Agent.Monitors.SSHMonitor.#ctor(Peach.Core.Agent.IAgent,System.String,System.Collections.Generic.Dictionary{System.String,Peach.Core.Variant})">
            <summary>
            </summary>
            <param name="agent">
            </param>
            <param name="name">
            </param>
            <param name="args">
            </param>
        </member>
        <member name="T:Peach.Core.Agent.Monitors.SaveFileMonitor">
            <summary>
            Save a file when a fault occurs.
            </summary>
        </member>
        <member name="T:Peach.Core.Analysis.Coverage">
            <summary>
            Abstract base class for performing code coverage via basic blocks
            for native binaries.  Each architecture implements this class.
            </summary>
            <remarks>
            So far only Windows has an implementation.
            </remarks>
        </member>
        <member name="M:Peach.Core.Analysis.Coverage.CreateInstance">
            <summary>
            Create an instance of this abstract class
            </summary>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Analysis.Coverage.BasicBlocksForExecutable(System.String,System.Boolean)">
            <summary>
            Collect all basic blocks in binary
            </summary>
            <param name="executable">
            </param>
            <param name="needsKilling">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Analysis.Coverage.CodeCoverageForExecutable(System.String,System.String,System.Boolean,System.Collections.Generic.List{System.UInt64})">
            <summary>
            Perform code coverage based on collection of basic blocks.  If
            not provided they will be generated by calling BasicBlocksForExecutable.
            </summary>
            <param name="executable">
            </param>
            <param name="arguments">
            </param>
            <param name="needsKilling">
            </param>
            <param name="basicBlocks">
            </param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.Analysis.CoverageImpl">
            <summary>
            Coverage implementation that utalizes PinTools
            </summary>
        </member>
        <member name="F:Peach.Core.Analysis.CoverageImpl._traceFolder">
            <summary>
            Temporary folder to store traces
            </summary>
        </member>
        <member name="F:Peach.Core.Analysis.CoverageImpl.pinExecutables">
            <summary>
            Executables for pin tools by OS and architecture.
            </summary>
        </member>
        <member name="F:Peach.Core.Analysis.CoverageImpl.pinTool">
            <summary>
            Pin tool dll by os and architecture.
            </summary>
        </member>
        <member name="M:Peach.Core.Analysis.CoverageImpl.BasicBlocksForExecutable(System.String,System.Boolean)">
            <summary>
            Collect all basic blocks in binary
            </summary>
            <param name="executable">
            </param>
            <param name="needsKilling">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Analysis.CoverageImpl.CodeCoverageForExecutable(System.String,System.String,System.Boolean,System.Collections.Generic.List{System.UInt64})">
            <summary>
            Perform code coverage based on collection of basic blocks.  If
            not provided they will be generated by calling BasicBlocksForExecutable.
            </summary>
            <param name="executable">
            </param>
            <param name="arguments">
            </param>
            <param name="needsKilling">
            </param>
            <param name="basicBlocks">
            </param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.Analysis.Minset">
            <summary>
            Perform analysis on sample sets to identify the smallest sample set
            that provides the largest code coverage.
            </summary>
        </member>
        <member name="M:Peach.Core.Analysis.Minset.LoadBlocks(System.String)">
            <summary>
            Load the blocks
            </summary>
            <param name="fileName">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Analysis.Minset.RunCoverage(System.String[],System.String[])">
            <summary>
            Perform coverage analysis of trace files.
            </summary>
            <remarks>
            Note: The sample and trace collections must have matching indexes.
            </remarks>
            <param name="sampleFiles">Collection of sample files</param>
            <param name="traceFiles">Collection of trace files for sample files</param>
            <returns>Returns the minimum set of smaple files.</returns>
        </member>
        <member name="M:Peach.Core.Analysis.Minset.Delta(System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32})">
            <summary>
            Are any of the childs items missing from master.
            </summary>
            <param name="child">
            </param>
            <param name="master">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Analysis.Minset.RunTraces(System.String,System.String,System.String,System.String[],System.Boolean)">
            <summary>
            Collect traces for a collection of sample files.
            </summary>
            <remarks>
            This method will use the TraceStarting and TraceCompleted events
            to report progress.
            </remarks>
            <param name="executable">Executable to run.</param>
            <param name="arguments">Executable arguments.  Must contain a "%s" placeholder for the sampe filename.</param>
            <param name="tracesFolder">Where to write trace files</param>
            <param name="sampleFiles">Collection of sample files</param>
            <param name="needsKilling">Does this command requiring forcefull killing to exit?</param>
            <returns>Returns a collection of trace files</returns>
        </member>
        <member name="M:Peach.Core.Analysis.Minset.RunSingleTrace(Peach.Core.Analysis.Coverage,System.String,System.String,System.String,System.Collections.Generic.List{System.UInt64},System.Boolean)">
            <summary>
            Create a single trace file based on code coverage stats for fileName.
            </summary>
            <param name="cov">Coverage stats</param>
            <param name="traceFile">Output trace to this filename</param>
            <param name="executable">Command to execute.</param>
            <param name="arguments">Command arguments.</param>
            <param name="basicBlocks">List of basic blocks to trap on</param>
            <param name="needsKilling">Does this process require killing?</param>
            <returns>True on success, false if a failure occured.</returns>
        </member>
        <member name="M:Peach.Core.Analyzer.asParser(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Replaces the parser for fuzzer definition.
            </summary>
            <param name="args">Command line arguments</param>
            <param name="fileName">File to parse</param>
        </member>
        <member name="M:Peach.Core.Analyzer.asParser(System.Collections.Generic.Dictionary{System.String,System.Object},System.IO.Stream)">
            <summary>
            </summary>
            <param name="args">
            </param>
            <param name="data">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Analyzer.asParserValidation(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Called to perform validation pass.
            </summary>
            <param name="args">Arguments</param>
            <param name="fileName">Filename to test</param>
            <returns>Throws PeachException on error.</returns>
        </member>
        <member name="T:Peach.Core.AnalyzerAttribute">
            <summary>
            Used to indicate a class is a valid Publisher and
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Analyzers.PitParser">
            <summary>
            This is the default analyzer for Peach.  It will
            parse a Peach PIT file (XML document) into a Peach DOM.
            </summary>
        </member>
        <member name="F:Peach.Core.Analyzers.PitParser.DEFINED_VALUES">
            <summary>
            args key for passing a dictionary of defined values to replace.
            </summary>
        </member>
        <member name="F:Peach.Core.Analyzers.PitParser.dataElementDefaults">
            <summary>
            Contains default attributes for DataElements
            </summary>
        </member>
        <member name="F:Peach.Core.Analyzers.PitParser.dataElementPitParsable">
            <summary>
            Mapping of XML ELement names to type as provided by PitParsableAttribute
            </summary>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.validatePit(System.String)">
            <summary>
            Validate PIT XML using Schema file.
            </summary>
            <param name="xmlData">Pit file to validate</param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handlePeach(Peach.Core.Dom.Dom,System.Xml.XmlNode,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Handle parsing the top level Peach node.
            </summary>
            <remarks>
            NOTE: This method is intended to be overriden (hence the virtual) and is
            			currently in use by Godel to extend the Pit Parser.
            </remarks>
            <param name="dom">Dom object</param>
            <param name="node">XmlNode to parse</param>
            <param name="args">Parser arguments</param>
            <returns>Returns the parsed Dom object.</returns>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.getReference(System.String,Peach.Core.Dom.DataElementContainer)">
            <summary>
            Resolve a 'ref' attribute.  Will throw a PeachException if
            namespace is given, but not found.
            </summary>
            <param name="name">Ref name to resolve.</param>
            <param name="container">Container to start searching from.</param>
            <returns>DataElement for ref or null if not found.</returns>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.getRef``1(Peach.Core.Dom.Dom,System.String,System.Func{Peach.Core.Dom.Dom,Peach.Core.OrderedDictionary{System.String,``0}})">
            <summary>
            Find a referenced Dom element by name, taking into account namespace prefixes.
            </summary>
            <typeparam name="T">Type of Dom element.</typeparam>
            <param name="dom">Dom to search in</param>
            <param name="refName">Name of reference</param>
            <param name="predicate">Selector predicate that returns the element collection</param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.finalUpdateRelations(System.Collections.Generic.ICollection{Peach.Core.Dom.DataModel})">
            <summary>
            Locate all relations and pair from/of.
            </summary>
            <remarks>
            After we have completed creating our base dom tree we will perform
            a second pass on all data models to locate every relation and resolve
            both from/of and verify both sides are connected correctly.
            After this, all relations will be bound to both from and of elements.
            </remarks>
            <param name="models">
            </param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handleCommonDataElementAttributes(System.Xml.XmlNode,Peach.Core.Dom.DataElement)">
            <summary>
            Handle common attributes such as the following:
            * mutable
            * contraint
            * pointer
            * pointerDepth
            * token
            </summary>
            <param name="node">XmlNode to read attributes from</param>
            <param name="element">Element to set attributes on</param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handleCommonDataElementChildren(System.Xml.XmlNode,Peach.Core.Dom.DataElement)">
            <summary>
            Handle parsing common dataelement children liek relation, fixupImpl and
            transformer.
            </summary>
            <param name="node">Node to read values from</param>
            <param name="element">Element to set values on</param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handleHint(System.Xml.XmlNode,Peach.Core.Dom.DataElement)">
            <summary>
            </summary>
            <param name="node">XmlNode tor read children elements from</param>
            <param name="element">Element to add items to</param>
        </member>
        <member name="M:Peach.Core.Analyzers.PitParser.handleDataElementContainer(System.Xml.XmlNode,Peach.Core.Dom.DataElementContainer)">
            <summary>
            Handle parsing child data types into containers.
            </summary>
            <param name="node">XmlNode tor read children elements from</param>
            <param name="element">Element to add items to</param>
        </member>
        <member name="F:Peach.Core.Analyzers.StringTokenAnalyzer.TOKENS">
            <summary>
            Default token set.  Order is important!
            </summary>
        </member>
        <member name="M:Peach.Core.Analyzers.StringTokenAnalyzer.splitOnToken(Peach.Core.Dom.DataElement,System.Char)">
            <summary>
            Split on token recursively
            </summary>
            <param name="el">
            </param>
            <param name="token">
            </param>
        </member>
        <member name="T:Peach.Core.ClassLoader">
            <summary>
            Methods for finding and creating instances of
            classes.
            </summary>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetAttributes``1(System.Type,System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Extension to the Type class. Return all attributes matching the specified type and predicate.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="type">Type in which the search should run over.</param>
            <param name="predicate">Returns an attribute if the predicate returns true or the predicate itself is null.</param>
            <returns>A generator which yields the attributes specified.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetAllByAttribute``1(System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Finds all types that are decorated with the specified Attribute type and matches the specified predicate.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="predicate">Returns a value if the predicate returns true or the predicate itself is null.</param>
            <returns>A generator which yields KeyValuePair elements of custom attribute and type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.GetAllTypesByAttribute``1(System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Finds all types that are decorated with the specified Attribute type and matches the specified predicate.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="predicate">Returns a value if the predicate returns true or the predicate itself is null.</param>
            <returns>A generator which yields elements of the type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.FindByAttribute``1(System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Finds the first type that matches the specified query.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="predicate">Returns a value if the predicate returns true or the predicate itself is null.</param>
            <returns>KeyValuePair of custom attribute and type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.FindTypeByAttribute``1(System.Func{System.Type,``0,System.Boolean})">
            <summary>
            Finds the first type that matches the specified query.
            </summary>
            <typeparam name="A">Attribute type to find.</typeparam>
            <param name="predicate">Returns a value if the predicate returns true or the predicate itself is null.</param>
            <returns>Returns only the Type found.</returns>
        </member>
        <member name="M:Peach.Core.ClassLoader.FindAndCreateByTypeAndName``1(System.String)">
            <summary>
            Find and create and instance of class by parent type and
            name.
            </summary>
            <typeparam name="T">Return Type.</typeparam>
            <param name="name">Name of type.</param>
            <returns>Returns a new instance of found type, or null.</returns>
        </member>
        <member name="M:Peach.Core.InheritParameterAttribute.#ctor(System.String)">
            <summary>
            Inherit parameters from a different plugin.
            </summary>
            <param name="parameter">The name of the parameter on the decorated object that contains the name of the object to inherit parameters from.</param>
        </member>
        <member name="M:Peach.Core.ParameterAttribute.#ctor(System.String,System.Type,System.String)">
            <summary>
            Constructs a REQUIRED parameter.
            </summary>
            <param name="name">
            </param>
            <param name="type">
            </param>
            <param name="description">
            </param>
        </member>
        <member name="M:Peach.Core.ParameterAttribute.#ctor(System.String,System.Type,System.String,System.String)">
            <summary>
            Constructs an OPTIONAL parameter.
            </summary>
            <param name="name">
            </param>
            <param name="type">
            </param>
            <param name="description">
            </param>
            <param name="defaultValue">
            </param>
        </member>
        <member name="T:Peach.Core.Cracker.DataCracker">
            <summary>
            Crack data into a DataModel.
            </summary>
        </member>
        <member name="T:Peach.Core.Cracker.DataCracker.Position">
            <summary>
            Helper class for tracking positions of cracked elements
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._sizedElements">
            <summary>
            Collection of all elements that have been cracked so far.
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._sizeRelations">
            <summary>
            List of all unresolved size relations.
            This occurs when the 'Of' is cracked before the 'From'.
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._dataStack">
            <summary>
            Stack of all BitStream objects passed to CrackData().
            This is used for determining absolute locations from relative offsets.
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.DataCracker._elementsWithAnalyzer">
            <summary>
            Elements that have analyzers attached.  We run them all post-crack.
            </summary>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.CrackData(Peach.Core.Dom.DataElement,Peach.Core.IO.BitStream)">
            <summary>
            Main entry method that will take a data stream and parse it into a data model.
            </summary>
            <remarks>
            Method will throw one of two exceptions on an error: CrackingFailure, or NotEnoughDataException.
            </remarks>
            <param name="element">DataElement to import data into</param>
            <param name="data">Data stream to read data from</param>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.GetElementSize(Peach.Core.Dom.DataElement)">
            <summary>
            Get the size of an element that has already been cracked.
            The size only has a value if the element has a length attribute
            or the element has a size relation that has successfully resolved.
            </summary>
            <param name="elem">Element to query</param>
            <returns>size of the element</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.HasCracked(Peach.Core.Dom.Relation)">
            <summary>
            Determines if the From half of a relation has been cracked.
            </summary>
            <param name="rel">The Relation to test.</param>
            <returns>True if the From half has been cracked, false otherwise.</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.OptimizeDataModel(Peach.Core.Dom.DataModel)">
            <summary>
            Perform optimizations of data model for cracking
            </summary>
            <remarks>
            Optimization can be performed once on a data model and used
            for any clones made.  Optimizations will increase the speed
            of data cracking.
            </remarks>
            <param name="model">DataModel to optimize</param>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.handleNode(Peach.Core.Dom.DataElement,Peach.Core.IO.BitStream)">
            <summary>
            Called to crack a DataElement based on an input stream.  This method
            will hand cracking off to a more specific method after performing
            some common tasks.
            </summary>
            <param name="elem">DataElement to crack</param>
            <param name="data">Input stream to use for data</param>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.findToken(Peach.Core.IO.BitStream,Peach.Core.IO.BitStream,System.Int64)">
            <summary>
            Searches data for the first occurance of token starting at offset.
            </summary>
            <param name="data">BitStream to search in.</param>
            <param name="token">BitStream to search for.</param>
            <param name="offset">How many bits after the current position of data to start searching.</param>
            <returns>The location of the token in data from the current position or null.</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.scan(Peach.Core.Dom.DataElement,System.Int64@,System.Collections.Generic.List{Peach.Core.Cracker.DataCracker.Mark},Peach.Core.Cracker.DataCracker.Mark,Peach.Core.Cracker.DataCracker.Until)">
            <summary>
            Scan elem and all children looking for a target element.
            The target can either be the first sized element or the first unsized element.
            If an unsized element is found, keep track of the determinism of the element.
            An element is determinstic if its size is unknown, but can be determined by calling
            crack(). Examples are a container with sized children or a null terminated string.
            </summary>
            <param name="elem">Element to start scanning at.</param>
            <param name="pos">The position of the scanner when 'until' occurs.</param>
            <param name="tokens">List of tokens found when scanning.</param>
            <param name="end">If non-null and an element with an offset relation is detected,
            record the element's absolute position and stop scanning.</param>
            <param name="until">When to stop scanning.
            Either first sized element or first unsized element.</param>
            <returns>Null if an unsized element was found.
            False if a deterministic element was found.
            True if all elements are sized.</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.getSize(Peach.Core.Dom.DataElement,Peach.Core.IO.BitStream)">
            <summary>
            Get the size of the data element.
            </summary>
            <param name="elem">Element to size</param>
            <param name="data">Bits to crack</param>
            <returns>Null if size is unknown or the size in bits.</returns>
        </member>
        <member name="M:Peach.Core.Cracker.DataCracker.lookahead(Peach.Core.Dom.DataElement,System.Int64@,System.Collections.Generic.List{Peach.Core.Cracker.DataCracker.Mark},Peach.Core.Cracker.DataCracker.Mark)">
            <summary>
            Scan all elements after elem looking for the first unsized element.
            If an unsized element is found, keep track of the determinism of the element.
            An element is determinstic if its size is unknown, but can be determined by calling
            crack(). Examples are a container with sized children or a null terminated string.
            </summary>
            <param name="elem">Start scanning at this element's next sibling.</param>
            <param name="pos">The position of the scanner when 'until' occurs.</param>
            <param name="tokens">List of tokens found when scanning.</param>
            <param name="end">If non-null and an element with an offset relation is detected,
            record the element's absolute position and stop scanning.
            Either first sized element or first unsized element.</param>
            <returns>Null if an unsized element was found.
            False if a deterministic element was found.
            True if all elements are sized.</returns>
        </member>
        <member name="T:Peach.Core.Cracker.ICrackable">
            <summary>
            Interface required by data cracker
            </summary>
        </member>
        <member name="M:Peach.Core.Cracker.ICrackable.Crack(Peach.Core.Cracker.DataCracker,Peach.Core.IO.BitStream)">
            <summary>
            Called by data cracker to crack data into DataElement instance.
            </summary>
            <param name="context">DataCracker instance</param>
            <param name="data">Data to crack</param>
        </member>
        <member name="F:Peach.Core.Cracker.IncomingStream._haveAllData">
            <summary>
            Have all data from underlying publisher
            </summary>
        </member>
        <member name="F:Peach.Core.Cracker.IncomingStream.data">
            <summary>
            Data for stream
            </summary>
        </member>
        <member name="M:Peach.Core.Cracker.IncomingStream.EnableRelativePosition(Peach.Core.Dom.DataElement)">
            <summary>
            Enable relative stream position.  This is for
            sized block support.  Enabling can be performed
            recursively.
            </summary>
            <param name="element">DataElement to make stream relative from.</param>
        </member>
        <member name="M:Peach.Core.Cracker.IncomingStream.DisableRelativePosition(Peach.Core.Dom.DataElement)">
            <summary>
            Disable relative stream position.  This is for
            sized block support.
            </summary>
            <param name="element">DataElement that stream was realtive to.</param>
        </member>
        <member name="T:Peach.Core.Dom.ActionType">
            <summary>
            Action types
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Action">
            <summary>
            Performs an Action such as sending output,
            calling a method, etc.
            </summary>
        </member>
        <member name="E:Peach.Core.Dom.Action.Starting">
            <summary>
            Action is starting to execute
            </summary>
        </member>
        <member name="E:Peach.Core.Dom.Action.Finished">
            <summary>
            Action has finished executing
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.dataSet">
            <summary>
            Data attached to action
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.dataModel">
            <summary>
            Current copy of the data model we are mutating.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.origionalDataModel">
            <summary>
            Origional copy of the data model we will be mutating.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.started">
            <summary>
            Action was started
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.finished">
            <summary>
            Action finished
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.error">
            <summary>
            Action errored
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.parameters">
            <summary>
            Array of parameters for a method call
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.result">
            <summary>
            Action result for a method call
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.setXpath">
            <summary>
            xpath for selecting set targets during slurp.
            </summary>
            <remarks>
            Can return multiple elements.  All returned elements
            will be updated with a new value.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Action.valueXpath">
            <summary>
            xpath for selecting value during slurp
            </summary>
            <remarks>
            Must return a single element.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Action.publisher">
            <summary>
            Name of publisher to use
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.when">
            <summary>
            Only run action when expression is true
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.onStart">
            <summary>
            Expression to run when action is starting
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.onComplete">
            <summary>
            Expression to run when action is completed
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.reference">
            <summary>
            Name of state to change to, type=ChangeState
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.method">
            <summary>
            Method to call
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.property">
            <summary>
            Property to operate on
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Action.dataModelRequired">
            <summary>
            Returns true if this action requires a dataModel
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Action.UpdateToOrigionalDataModel">
            <summary>
            Update any DataModels we contain to new clones of
            origionalDataModel.
            </summary>
            <remarks>
            This should be performed in StateModel to every State/Action at
            start of the iteration.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.Agent">
            <summary>
            A dom element to hold Agent configuration information
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Agent.name">
            <summary>
            Name for agent
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Agent.url">
            <summary>
            URL of agent
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Agent.password">
            <summary>
            Optional password for agent
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Agent.platform">
            <summary>
            Limit Agent to specific platform.  Platform of unknown is
            any OS.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Agent.monitors">
            <summary>
            List of monitors Agent should spin up.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Array">
            <summary>
            Array of data elements.  Can be
            zero or more elements.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Array.ExpandTo(System.Int32)">
            <summary>
            Expands the size of the array to be 'num' long.
            Does this by adding the same instance of the last
            item in the array until the Count is num.
            </summary>
            <param name="num">The total size the array should be.</param>
        </member>
        <member name="T:Peach.Core.Dom.Blob">
            <summary>
            Binary large object data element
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Block">
            <summary>
            Block element
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Choice">
            <summary>
            Choice allows the selection of a single
            data element based on the current data set.
            The other options in the choice are available
            for mutation by the mutators.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.CountRelation">
            <summary>
            Array count relation
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Data">
            <summary>
            Data specification for a DataModel
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.DataType">
            <summary>
            Type of Data
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.LengthType">
            <summary>
            Length types
            </summary>
            <remarks>
            The "length" property defaults to Bytes.  Not all
            implementations of DataElement will support all LengthTypes.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.DataElement">
            <summary>
            Base class for all data elements.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement.MUTATE_OVERRIDE_FIXUP">
            <summary>
            Mutated vale override's fixupImpl
            - Default Value
            - Relation
            - Fixup
            - Type contraints
            - Transformer
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement.MUTATE_OVERRIDE_TRANSFORMER">
            <summary>
            Mutated value overrides transformers
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement.MUTATE_OVERRIDE_TYPE_CONSTRAINTS">
            <summary>
            Mutated value overrides type constraints (e.g. string length,
            null terminated, etc.)
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement.MUTATE_OVERRIDE_RELATIONS">
            <summary>
            Mutated value overrides relations.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement.MUTATE_OVERRIDE_TYPE_TRANSFORM">
            <summary>
            Mutated value overrides type transforms.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement.MUTATE_DEFAULT">
            <summary>
            Default mutate value
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement._hasLength">
            <summary>
            Does this element have a defined length?
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement._length">
            <summary>
            Length in bits
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataElement._lengthType">
            <summary>
            Determines how the length property works.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.Properties">
            <summary>
            Dynamic properties
            </summary>
            <remarks>
            Any objects added to properties must be serializable!
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.fullName">
            <summary>
            Full qualified name of DataElement to
            root DataElement.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.constraint">
            <summary>
            Constraint on value of data element.
            </summary>
            <remarks>
            This
            constraint is only enforced when loading data into
            the object.  It will not affect values that are
            produced during fuzzing.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.isReference">
            <summary>
            Is this DataElement created by a
            reference to another DataElement?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.referenceName">
            <summary>
            If created by reference, has the reference name
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.isLeafNode">
            <summary>
            Is this a leaf of the DataModel tree?
            True if DataElement has no children.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.hasLength">
            <summary>
            Does element have a length?  This is
            separate from Relations.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.isDeterministic">
            <summary>
            Is the length of the element deterministic.
            This is the case if the element hasLength or
            if the element has a specific end. For example,
            a null terminated string.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.length">
            <summary>
            Length of element in lengthType units.
            </summary>
            <remarks>
            In the case that LengthType == "Calc" we will evaluate the
            expression.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.lengthAsBits">
            <summary>
            Returns length as bits.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.lengthType">
            <summary>
            Type of length.
            </summary>
            <remarks>
            Not all DataElement implementations support "Chars".
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.DefaultValue">
            <summary>
            Default value for this data element.
            Changing the default value will invalidate
            the model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.MutatedValue">
            <summary>
            Current mutated value (if any) for this data element.
            Changing the MutatedValue will invalidate the model.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.InternalValue">
            <summary>
            Get the Internal Value of this data element
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.Value">
            <summary>
            Get the final Value of this data element
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.GenerateCount">
            <summary>
            How many times GenerateValue has been called on this element
            </summary>
            <returns>
            </returns>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.fixup">
            <summary>
            Fixup for this data element.  Can be null.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.placement">
            <summary>
            Placement for this data element. Can be null.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.transformer">
            <summary>
            Transformer for this data element.  Can be null.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.DataElement.relations">
            <summary>
            Relations for this data element.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Clone">
            <summary>
            Creates a deep copy of the DataElement, and updates the appropriate Relations.
            </summary>
            <returns>Returns a copy of the DataElement.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Clone(System.String)">
            <summary>
            Creates a deep copy of the DataElement, and updates the appropriate Relations.
            </summary>
            <param name="newName">What name to set on the cloned DataElement</param>
            <returns>Returns a copy of the DataElement.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Clone(System.String,System.Int64@)">
            <summary>
            Creates a deep copy of the DataElement, and updates the appropriate Relations.
            </summary>
            <param name="newName">What name to set on the cloned DataElement</param>
            <param name="size">The size in bytes used when performing the copy. Useful for debugging statistics.</param>
            <returns>Returns a copy of the DataElement.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.evaulateAnalyzers">
            <summary>
            Recursively execute analyzers
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.nextSibling">
            <summary>
            Find our next sibling.
            </summary>
            <returns>Returns sibling or null.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.previousSibling">
            <summary>
            Find our previous sibling.
            </summary>
            <returns>Returns sibling or null.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.Invalidate">
            <summary>
            Call to invalidate current element and cause rebuilding
            of data elements dependent on this element.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.GenerateInternalValue">
            <summary>
            Generate the internal value of this data element
            </summary>
            <returns>Internal value in .NET form</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.GenerateValue">
            <summary>
            Generate the final value of this data element
            </summary>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateAllElementsFromHere(Peach.Core.Dom.DataElement)">
            <summary>
            Enumerates all DataElements starting from 'start.'
            This method will first return children, then siblings, then children
            of siblings as it walks up the parent chain.  It will not return
            any duplicate elements.
            Note: This is not the fastest way to enumerate all elements in the
            tree, it's specifically intended for findings Elements in a search
            pattern that matches a persons assumptions about name resolution.
            </summary>
            <param name="start">Starting DataElement</param>
            <returns>All DataElements in model.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateAllElementsFromHere(Peach.Core.Dom.DataElement,System.Collections.Generic.List{Peach.Core.Dom.DataElement})">
            <summary>
            Enumerates all DataElements starting from 'start.'
            This method will first return children, then siblings, then children
            of siblings as it walks up the parent chain.  It will not return
            any duplicate elements.
            Note: This is not the fastest way to enumerate all elements in the
            tree, it's specifically intended for findings Elements in a search
            pattern that matches a persons assumptions about name resolution.
            </summary>
            <param name="start">Starting DataElement</param>
            <param name="cache">Cache of DataElements already returned</param>
            <returns>All DataElements in model.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateChildrenElements(Peach.Core.Dom.DataElement,System.Collections.Generic.List{Peach.Core.Dom.DataElement})">
            <summary>
            Enumerates all children starting from, but not including
            'start.'  Will also enumerate the children of children until
            leaf nodes are hit.
            </summary>
            <param name="start">Starting DataElement</param>
            <param name="cache">Cache of already seen elements</param>
            <returns>Returns DataElement children of start.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.find(System.String)">
            <summary>
            Find data element with specific name.
            </summary>
            <remarks>
            We will search starting at our level in the tree, then moving
            to children from our level, then walk up node by node to the
            root of the tree.
            </remarks>
            <param name="name">Name to search for</param>
            <returns>Returns found data element or null.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateElementsUpTree">
            <summary>
            Enumerate all items in tree starting with our current position
            then moving up towards the root.
            </summary>
            <remarks>
            This method uses yields to allow for efficient use even if the
            quired node is found quickely.
            The method in which we return elements should match a human
            search pattern of a tree.  We start with our current position and
            return all children then start walking up the tree towards the root.
            At each parent node we return all children (excluding already returned
            nodes).
            This method is ideal for locating objects in the tree in a way indented
            a human user.
            </remarks>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateElementsUpTree(System.Collections.Generic.List{Peach.Core.Dom.DataElement})">
            <summary>
            Enumerate all items in tree starting with our current position
            then moving up towards the root.
            </summary>
            <remarks>
            This method uses yields to allow for efficient use even if the
            quired node is found quickely.
            The method in which we return elements should match a human
            search pattern of a tree.  We start with our current position and
            return all children then start walking up the tree towards the root.
            At each parent node we return all children (excluding already returned
            nodes).
            This method is ideal for locating objects in the tree in a way indented
            a human user.
            </remarks>
            <param name="knownParents">List of known parents to stop duplicates</param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateAllElements">
            <summary>
            Enumerate all child elements recursevely.
            </summary>
            <remarks>
            This method will return this objects direct children
            and finally recursevely return children's children.
            </remarks>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.EnumerateAllElements(System.Collections.Generic.List{Peach.Core.Dom.DataElement})">
            <summary>
            Enumerate all child elements recursevely.
            </summary>
            <remarks>
            This method will return this objects direct children
            and finally recursevely return children's children.
            </remarks>
            <param name="knownParents">List of known parents to skip</param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.ReadSizedData(Peach.Core.IO.BitStream,System.Nullable{System.Int64},System.Int64)">
            <summary>
            Helper fucntion to obtain a bitstream sized for this element
            </summary>
            <param name="data">Source BitStream</param>
            <param name="size">Length of this element</param>
            <param name="read">Length of bits already read of this element</param>
            <returns>BitStream of length 'size - read'</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElement.isChildOf(Peach.Core.Dom.DataElement,System.String@)">
            <summary>
            Determines whether or not a DataElement is a child of this DataElement.
            Computes the relative name from 'this' to 'dataElement'.  If 'dataElement'
            is not a child of 'this', the absolute path of 'dataElement' is computed.
            </summary>
            <param name="dataElement">The DataElement to test for a child relationship.</param>
            <param name="relName">String to receive the realitive name of 'dataElement'.</param>
            <returns>Returns true if 'dataElement' is a child, false otherwise.</returns>
        </member>
        <member name="T:Peach.Core.Dom.DataElementContainer">
            <summary>
            Abstract base class for DataElements that contain other
            data elements.  Such as Block, Choice, or Flags.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.evaulateAnalyzers">
            <summary>
            Recursively execute analyzers
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.ContainsKey(System.String)">
            <summary>
            Does container contain child element with name key?
            </summary>
            <param name="key">Name of child element to check</param>
            <returns>Returns true if child exits</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.EnumerateAllElements(System.Collections.Generic.List{Peach.Core.Dom.DataElement})">
            <summary>
            Enumerate all child elements recursevely.
            </summary>
            <remarks>
            This method will return this objects direct children
            and finally recursevely return children's children.
            </remarks>
            <param name="knownParents">List of known parents to skip</param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.isParentOf(Peach.Core.Dom.DataElement)">
            <summary>
            Check if we are a parent of an element.  This is
            true even if we are not the direct parent, but several
            layers up.
            </summary>
            <param name="element">Element to check</param>
            <returns>Returns true if we are a parent of element.</returns>
        </member>
        <member name="M:Peach.Core.Dom.DataElementContainer.prettyPrint(System.Text.StringBuilder,System.Int32)">
            <summary>
            Create a pretty string representation of model from here.
            </summary>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.Dom.DataModel">
            <summary>
            DataModel is just a top level Block.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataModel.dom">
            <summary>
            Dom parent of data model if any
            </summary>
            <remarks>
            A data model can be the child of two (okay three) different types,
            1. Dom (dom.datamodel collection)
            2. Action (Action.dataModel)
            3. ActionParam (Action.parameters[0].dataModel)
            This variable is one of those parent holders.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.DataModel.action">
            <summary>
            Action parent of data model if any
            </summary>
            <remarks>
            A data model can be the child of two (okay three) different types,
            1. Dom (dom.datamodel collection)
            2. Action (Action.dataModel)
            3. ActionParam (Action.parameters[0].dataModel)
            This variable is one of those parent holders.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.DataSet">
            <summary>
            Specify a set of Data for a DataModel
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.DataSet.Datas">
            <summary>
            Collection of Data objects
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Dom.evaulateDataModelAnalyzers">
            <summary>
            Execute all analyzers on all data models in DOM.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Dom.getRef``1(System.String,System.Func{Peach.Core.Dom.Dom,Peach.Core.OrderedDictionary{System.String,``0}})">
            <summary>
            Find a referenced Dom element by name, taking into account namespace prefixes.
            </summary>
            <typeparam name="T">Type of Dom element.</typeparam>
            <param name="refName">Name of reference</param>
            <param name="predicate">Selector predicate that returns the element collection</param>
            <returns>The named Dom element or null if not found.</returns>
        </member>
        <member name="M:Peach.Core.Dom.Flag.Overlapps(System.Int32,System.Int32)">
            <summary>
            Determines if a flag at position 'position' with size 'size' overlapps this element
            </summary>
            <param name="position">Position to test</param>
            <param name="size">Size to test</param>
            <returns>True if overlapps, false otherwise</returns>
        </member>
        <member name="T:Peach.Core.Dom.Hint">
            <summary>
            Hints are attached to data elements providing information
            for mutators.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.HintAttribute">
            <summary>
            Used to indicate a mutator supports a type of Hint
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.INamed">
            <summary>
            Named object that is part of Peach DOM
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Monitor">
            <summary>
            A dom element to hold Monitor config information
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Number">
            <summary>
            A numerical data element.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.OffsetRelation">
            <summary>
            Byte offset relation
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.OffsetRelation.calculateOffset(Peach.Core.Dom.DataElement,Peach.Core.Dom.DataElement)">
            <summary>
            Caluclate the offset in bytes between two data elements.
            </summary>
            <param name="from">
            </param>
            <param name="to">
            </param>
            <returns>Returns the offset in bits between two elements.  Return can be negative.</returns>
        </member>
        <member name="M:Peach.Core.Dom.OffsetRelation.findCommonRoot(Peach.Core.Dom.DataElement,Peach.Core.Dom.DataElement)">
            <summary>
            Locate the nearest common ancestor conainer.
            </summary>
            <remarks>
            To calculate the offset of elem2 from elem1 we need a the
            nearest common ancestor.  From that ancestor we can determine
            the offset of the two elements.  If the elements do not share
            a common ancestor we cannot calculate the offset.
            </remarks>
            <param name="elem1">
            </param>
            <param name="elem2">
            </param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.IOrderedDictionary`2">
            <summary>
            Represents a generic collection of key/value pairs that are ordered independently of the key and value.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary</typeparam>
        </member>
        <member name="P:Peach.Core.IOrderedDictionary`2.Item(System.Int32)">
            <summary>
            Gets or sets the value at the specified index.
            </summary>
            <param name="index">The zero-based index of the value to get or set.</param>
            <value>The value of the item at the specified index.</value>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is less than 0.<br />
            -or-<br /><paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ICollection.Count" />.</exception>
        </member>
        <member name="M:Peach.Core.IOrderedDictionary`2.Insert(System.Int32,`0,`1)">
            <summary>
            Inserts a new entry into the <see cref="T:IOrderedDictionary`2">IOrderedDictionary&lt;TKey,TValue&gt;</see> collection with the specified key and value at the specified index.
            </summary>
            <param name="index">The zero-based index at which the element should be inserted.</param>
            <param name="key">The key of the entry to add.</param>
            <param name="value">The value of the entry to add. The value can be <null /> if the type of the values in the dictionary is a reference type.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is less than 0.<br />
            -or-<br /><paramref name="index" /> is greater than <see cref="P:System.Collections.ICollection.Count" />.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:IOrderedDictionary`2">IOrderedDictionary&lt;TKey,TValue&gt;</see>.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:IOrderedDictionary`2">IOrderedDictionary&lt;TKey,TValue&gt;</see> is read-only.<br />
            -or-<br />
            The <see cref="T:IOrderedDictionary`2">IOrderedDictionary&lt;TKey,TValue&gt;</see> has a fized size.</exception>
        </member>
        <member name="M:Peach.Core.IOrderedDictionary`2.IndexOfKey(`0)">
            <summary>
            Returns the zero-based index of the specified key in the <see cref="T:OrderedDictionary`2">OrderedDictionary&lt;TKey,TValue&gt;</see></summary>
            <param name="key">The key to locate in the <see cref="T:OrderedDictionary`2">OrderedDictionary&lt;TKey,TValue&gt;</see></param>
            <returns>The zero-based index of <paramref name="key" />, if <paramref name="key" /> is found in the <see cref="T:OrderedDictionary`2">OrderedDictionary&lt;TKey,TValue&gt;</see>; otherwise, -1</returns>
            <remarks>This method performs a linear search; therefore it has a cost of O(n) at worst.</remarks>
        </member>
        <member name="T:Peach.Core.OrderedDictionary`2">
            <summary>
            Represents a generic collection of key/value pairs that are ordered independently of the key and value.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary</typeparam>
        </member>
        <member name="M:Peach.Core.OrderedDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:OrderedDictionary`2">OrderedDictionary&lt;TKey,TValue&gt;</see> class.
            </summary>
        </member>
        <member name="M:Peach.Core.OrderedDictionary`2.IndexOfKey(`0)">
            <summary>
            Returns the zero-based index of the specified key in the <see cref="T:OrderedDictionary`2">OrderedDictionary&lt;TKey,TValue&gt;</see></summary>
            <param name="key">The key to locate in the <see cref="T:OrderedDictionary`2">OrderedDictionary&lt;TKey,TValue&gt;</see></param>
            <returns>The zero-based index of <paramref name="key" />, if <paramref name="key" /> is found in the <see cref="T:OrderedDictionary`2">OrderedDictionary&lt;TKey,TValue&gt;</see>; otherwise, -1</returns>
            <remarks>This method performs a linear search; therefore it has a cost of O(n) at worst.</remarks>
        </member>
        <member name="T:Peach.Core.Dom.Padding">
            <summary>
            Providing padding bytes to a DataElementContainer.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Padding.#ctor">
            <summary>
            Create a padding element.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Padding.#ctor(System.String)">
            <summary>
            Create a padding element.
            </summary>
            <param name="name">Name of padding element</param>
        </member>
        <member name="P:Peach.Core.Dom.Padding.alignment">
            <summary>
            Byte alignment (8, 16, etc).
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Padding.alignedTo">
            <summary>
            Element to pull size to align.  If null use parent.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Placement">
            <summary>
            Hints are attached to data elements providing information
            for mutators.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.Relation">
            <summary>
            Base class for all data element relations
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Relation.ExpressionGet">
            <summary>
            Expression that is run when getting the value.
            </summary>
            <remarks>
            This expression is only run when the data cracker
            has identified a size relation exists and is getting
            the value from the "from" side of the relation.
            The expressionGet will only get executed when direcly calling
            the Relation.GetValue() method directly.  It is not called from
            DataElement by design.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Relation.ExpressionSet">
            <summary>
            Expression that is run when setting the value.
            </summary>
            <remarks>
            This expression can be called numerouse times.  It will be
            executed any time the attached data element re-generates it's
            value (internal or real).
            The ExpressionSet is executed typically from DataElement.GenerateInteralValue() via
            Relation.CalculateFromValue().  As such this expression should limit the amount of
            time intensive tasks it performs.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Relation.parent">
            <summary>
            Parent of relation.  This is
            typically our From as well.
            </summary>
            <remarks>
            We are now adding the Relation to both our
            "from" and "of" side.  The meaning of parent is nolonger
            clear and should be removed in the future.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.Relation.OfName">
            <summary>
            Name of DataElement used to generate our value.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Relation.FromName">
            <summary>
            Name of DataElement that receives our value
            when generated.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Relation.Of">
            <summary>
            DataElement used to generate our value.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Relation.From">
            <summary>
            DataElement that receives our value
            when generated.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.Relation.OfInvalidated(System.Object,System.EventArgs)">
            <summary>
            Handle invalidated event from "of" side of
            relation.  Need to invalidate "from".
            </summary>
            <param name="sender">
            </param>
            <param name="e">
            </param>
        </member>
        <member name="M:Peach.Core.Dom.Relation.CalculateFromValue">
            <summary>
            Calculate the new From value based on Of
            </summary>
            <remarks>
            This method is called every time our attached DataElement re-generates it's
            value by calling DataElement.GenerateInteralValue().
            </remarks>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Dom.Relation.GetValue">
            <summary>
            Get value from our "from" side.
            </summary>
            <remarks>
            Gets the value from our "from" side and run it through expressionGet (if set).
            This method is only called by the DataCracker and never from DataElement.
            </remarks>
        </member>
        <member name="M:Peach.Core.Dom.Relation.SetValue(Peach.Core.Variant)">
            <summary>
            Set value on from side
            </summary>
            <remarks>
            I'm not sure this method is used anymore.  It's been replaced by CalculateFromValue.
            TODO - Remove me?
            </remarks>
            <param name="value">
            </param>
        </member>
        <member name="M:Peach.Core.Dom.Relation.FindCommonParent(Peach.Core.Dom.DataElement,Peach.Core.Dom.DataElement)">
            <summary>
            Find the first common parent between two DataElements
            </summary>
            <param name="elem1">
            </param>
            <param name="elem2">
            </param>
            <returns>Common parent of null</returns>
        </member>
        <member name="T:Peach.Core.Dom.RelationAttribute">
            <summary>
            Used to indicate a class is a valid Relation and
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.RelationContainer">
            <summary>
            Abstract base class for DataElements that contain other
            data elements.  Such as Block, Choice, or Flags.
            </summary>
        </member>
        <member name="T:Peach.Core.Dom.SizeRelation">
            <summary>
            Byte size relation.
            </summary>
        </member>
        <member name="E:Peach.Core.Dom.State.Starting">
            <summary>
            State is starting to execute.
            </summary>
        </member>
        <member name="E:Peach.Core.Dom.State.Finished">
            <summary>
            State has finished executing.
            </summary>
        </member>
        <member name="E:Peach.Core.Dom.State.ChangingState">
            <summary>
            Changing to another state.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.started">
            <summary>
            Has the state started?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.finished">
            <summary>
            Has the start completed?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.error">
            <summary>
            Has an error occured?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.State.runCount">
            <summary>
            How many times has this state run
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.StateModel.states">
            <summary>
            All states in state model.
            </summary>
        </member>
        <member name="E:Peach.Core.Dom.StateModel.Starting">
            <summary>
            StateModel is starting to execute.
            </summary>
        </member>
        <member name="E:Peach.Core.Dom.StateModel.Finished">
            <summary>
            StateModel has finished executing.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.StateModel.initialState">
            <summary>
            The initial state to run when state machine executes.
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.StateModel.Run(Peach.Core.RunContext)">
            <summary>
            Start running the State Machine
            </summary>
            <remarks>
            This will start the initial State.
            </remarks>
            <param name="context">
            </param>
        </member>
        <member name="T:Peach.Core.Dom.String">
            <summary>
            String data element.  String elements support numerouse encodings
            such as straight ASCII through UTF-32.  Both little and big endian
            strings are supported.
            Strings also support standard attributes such as length, null termination,
            etc.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.String.stringType">
            <summary>
            String type/encoding to be used.  Default is
            ASCII.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.String.nullTerminated">
            <summary>
            Is string null terminated?  For ASCII strings this
            is a single NULL characters, for WCHAR's, two NULL
            characters are used.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.String.padCharacter">
            <summary>
            Pad character for string.  Defaults to NULL.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.String.length">
            <summary>
            Length of element in lengthType units.
            </summary>
            <remarks>
            In the case that LengthType == "Calc" we will evaluate the
            expression.
            </remarks>
        </member>
        <member name="P:Peach.Core.Dom.String.lengthAsBits">
            <summary>
            Returns length as bits.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Test.nonDeterministicActions">
            <summary>
            Do not fault when actions miss-match
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.Test.includedMutators">
            <summary>
            List of mutators to include in run
            </summary>
            <remarks>
            If exclude is empty, and this collection contains values, then remove all mutators and only
            include these.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.Test.excludedMutators">
            <summary>
            List of mutators to exclude from run
            </summary>
            <remarks>
            If include is empty then use all mutators excluding those in this list.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.Test.mutables">
            <summary>
            Collection of xpaths to mark state model/data models as mutable true/false
            at runtime.  This collection is set using Include and Exclude elements in a
            Test definition.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.replayEnabled">
            <summary>
            Should iterations be replayed when a fault occurs.
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.waitTime">
            <summary>
            Time to wait in seconds between each test case. Value can be fractional
            (0.25). Defaults to zero (0).
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.Test.faultWaitTime">
            <summary>
            Time to wait in seconds between each test case when reproducing faults. Value can be fractional
            (0.25). Defaults to two (2) seconds.
            </summary>
            <remarks>
            This value should be large enough to make sure a fault is detected at the correct
            iteration.  We only wait this time when verifying a fault was detected.
            </remarks>
        </member>
        <member name="T:Peach.Core.Dom.XPath.PeachXPathNavigator">
            <summary>
            Create an XPath Navigator for Peach DOM objects.
            </summary>
            <remarks>
            The XPath query syntax is the purfect way to select nodes
            from a Peach DOM.  By implementing an XPathNavigator we
            should beable to use the built in .NET XPath system with
            our Peach DOM.
            This XPath navigator will only search root -&gt; run -&gt; test -&gt; stateModel -&gt; States* -&gt; Actions* -&gt; DataModels*.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.XPath.PeachXPathNavigator.AttributeMatrix">
            <summary>
            Attributes for each known type
            </summary>
            <remarks>
            List of property names that we will expose as "attributes"
            for the xpath expressions.
            </remarks>
        </member>
        <member name="F:Peach.Core.Dom.XPath.PeachXPathNavigator.NodeTypeMap">
            <summary>
            Map between Type and PeachXPathNodeType
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.XPath.PeachXPathNavigator.dom">
            <summary>
            The Peach DOM we are navigating.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.XPath.PeachXPathNavigator.currentNode">
            <summary>
            The current node/position in the dom.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.XPath.PeachXPathNavigator.currentNodeType">
            <summary>
            Type of current node.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.XPath.PeachXPathNavigator.attributeIndex">
            <summary>
            Current attribute index.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.XPath.PeachXPathNavigator.testIndex">
            <summary>
            Current test index.
            </summary>
        </member>
        <member name="F:Peach.Core.Dom.XPath.PeachXPathNavigator.iteratingAttributes">
            <summary>
            Are we iterating attributes?
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.XmlAttribute.attributeName">
            <summary>
            XML attribute name
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.XmlAttribute.ns">
            <summary>
            XML Namespace for element
            </summary>
        </member>
        <member name="M:Peach.Core.Dom.XmlAttribute.GenerateXmlAttribute(Peach.Core.Dom.PeachXmlDoc,System.Xml.XmlNode)">
            <summary>
            Generate a System.Xml.XmlAttribute instance and populate with
            correct information.
            </summary>
            <param name="doc">XmlDocument this attribute will be part of.</param>
            <param name="parent">The parent XmlNode</param>
            <returns>Returns a valid instance of an XmlAttribute.</returns>
        </member>
        <member name="P:Peach.Core.Dom.XmlElement.elementName">
            <summary>
            XML Element tag name
            </summary>
        </member>
        <member name="P:Peach.Core.Dom.XmlElement.ns">
            <summary>
            XML Namespace for element
            </summary>
        </member>
        <member name="T:Peach.Core.Engine">
            <summary>
            The main Peach fuzzing engine!
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.TestStarting">
            <summary>
            Fired when a Test is starting.  This could be fired
            multiple times after the RunStarting event if the Run
            contains multiple Tests.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.IterationStarting">
            <summary>
            Fired at the start of each iteration.  This event will
            be fired often.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.IterationFinished">
            <summary>
            Fired at end of each iteration.  This event will be fired often.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.ReproFault">
            <summary>
            Fired when a Fault is detected and the engine starts retrying to reproduce it.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.ReproFailed">
            <summary>
            Fired when a Fault is is unable to be reproduced
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.Fault">
            <summary>
            Fired when a Fault is detected.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.TestFinished">
            <summary>
            Fired when a Test is finished.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.TestError">
            <summary>
            Fired when an error occurs during a Test.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.HaveCount">
            <summary>
            Fired when we know the count of iterations the Test will take.
            </summary>
        </member>
        <member name="E:Peach.Core.Engine.HaveParallel">
            <summary>
            Fired when we know the range of iterations the parallel Test will take.
            </summary>
        </member>
        <member name="M:Peach.Core.Engine.startFuzzing(Peach.Core.Dom.Dom,Peach.Core.RunConfiguration)">
            <summary>
            Run the default fuzzing run in the specified dom.
            </summary>
            <param name="dom">
            </param>
            <param name="config">
            </param>
        </member>
        <member name="M:Peach.Core.Engine.startFuzzing(Peach.Core.RunContext)">
            <summary>
            Start fuzzing using a RunContext object to provide
            needed configuration.  This allows the caller to pre-configure
            any Agents prior to calling the fuzzing engine.
            </summary>
            <param name="context">Fuzzing configuration</param>
        </member>
        <member name="M:Peach.Core.Engine.runTest(Peach.Core.Dom.Dom,Peach.Core.Dom.Test,Peach.Core.RunContext)">
            <summary>
            Run a test case.  Contains main fuzzing loop.
            </summary>
            <param name="dom">
            </param>
            <param name="test">
            </param>
            <param name="context">
            </param>
        </member>
        <member name="M:Peach.Core.XmlExtensions.hasAttr(System.Xml.XmlNode,System.String)">
            <summary>
            Tests if an attribute exists on an XmlNode
            </summary>
            <param name="node">Node to test</param>
            <param name="name">Attribute name to check for</param>
            <returns>True if atribute exists, false otherwise</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrString(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as a string.
            Throws an error if the attribute does not exist
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as a string</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrInt(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as an int.
            Throws an error if the attribute does not exist or
            if the value can not be converted to an int.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as an int</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrBool(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as a bool.
            Throws an error if the attribute does not exist or
            if the value can not be converted to a bool.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as a bool</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttrChar(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the value of an xml attribute as a char.
            Throws an error if the attribute does not exist or
            if the value can not be converted to a char.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <returns>Attribute value as a char</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Gets the value of an xml attribute as a string.
            Throws an error if the attribute value can not be converted to a string.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as a string</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Gets the value of an xml attribute as a bool.
            Throws an error if the attribute value can not be converted to a bool.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as a bool</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.Int32)">
            <summary>
            Gets the value of an xml attribute as an int.
            Throws an error if the attribute value can not be converted to an int.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as an int</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.getAttr(System.Xml.XmlNode,System.String,System.Char)">
            <summary>
            Gets the value of an xml attribute as a char.
            Throws an error if the attribute value can not be converted to a char.
            Returns the defaultValue if the attribute is not set.
            </summary>
            <param name="node">Xml node</param>
            <param name="name">Name of the attribute</param>
            <param name="defaultValue">Value to use when the attribute is not set</param>
            <returns>Attribute value as a char</returns>
        </member>
        <member name="M:Peach.Core.XmlExtensions.AppendAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Set attribute on XmlNode object.
            </summary>
            <param name="node">XmlNode to set attribute on</param>
            <param name="name">Name of attribute</param>
            <param name="value">Value of attribute</param>
        </member>
        <member name="M:Peach.Core.Fixup.fixup(Peach.Core.Dom.DataElement)">
            <summary>
            Perform fixup operation
            </summary>
            <param name="obj">Parent data element</param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.Fixups.Libraries.CiscoCDPChecksum">
            <summary>
            Computes the checksum in Host order for an array of bytes and
            compensates for Cisco off-by-one.
            </summary>
        </member>
        <member name="T:Peach.Core.Fixups.Libraries.CRCTool">
            <summary>
            Tool to calculate and add CRC codes to a string
            ***************************************************************************
            Copyright (c) 2003 Thoraxcentrum, Erasmus MC, The Netherlands.
            Written by Marcel de Wijs with help from a lot of others,
            especially Stefan Nelwan
            This code is for free. I ported it from several different sources to C#.
            For comments: Marcel_de_Wijs@hotmail.com
            ***************************************************************************
            </summary>
        </member>
        <member name="M:Peach.Core.Fixups.Libraries.CRCTool.crctablefast(System.Byte[])">
            <summary>
            4 ways to calculate the crc checksum. If you have to do a lot of encoding
            you should use the table functions. Since they use precalculated values, which
            saves some calculating.
            </summary>.</member>
        <member name="M:Peach.Core.Fixups.Libraries.CRCTool.crctablefast(System.Byte[],System.UInt64)">
            <summary>
            4 ways to calculate the crc checksum. If you have to do a lot of encoding
            you should use the table functions. Since they use precalculated values, which
            saves some calculating.
            </summary>.</member>
        <member name="M:Peach.Core.Fixups.Libraries.CRCTool.CalcCRCITT(System.Byte[])">
            <summary>
            CalcCRCITT is an algorithm found on the web for calculating the CRCITT checksum
            It is included to demonstrate that although it looks different it is the same
            routine as the crcbitbybit* functions. But it is optimized and preconfigured for CRCITT.
            </summary>
        </member>
        <member name="T:Peach.Core.Fixups.Libraries.InternetChecksum">
            <summary>
            Computes the checksum in Host order for an array of bytes
            </summary>
        </member>
        <member name="T:Peach.Core.Fixups.Libraries.InternetFixup">
            <summary>
            Base class for internet checksum fixups
            </summary>
        </member>
        <member name="T:Peach.Core.Fixups.ScriptFixup">
            <summary>
            Proxy class to allow writing fixups in a scripting language like python
            or ruby.
            </summary>
            <remarks>
            The constructor will be passed a reference to our instance as the only
            argument.  A method "fixup" will be called, passing in the element and expecting
            a byte[] array as output.
            </remarks>
        </member>
        <member name="T:Peach.Core.IO.BitStream">
            <summary>
            This stream is how all data is stored and read by
            Peach data elements.  It supports padded and unpadded
            reading/writing and accessing data stream as bits and
            bytes.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.BitStream.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Peach.Core.IO.BitStream.#ctor(System.IO.Stream)">
            <summary>
            Constructor for BitStream class
            </summary>
            <param name="stream">Use stream as initial stream data.</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.#ctor(System.Byte[])">
            <summary>
            Constructor for BitStream class
            </summary>
            <param name="buff">Use buff as initial stream data.</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Constructor for BitStream class
            </summary>
            <param name="buff">Use buff as initial stream data.</param>
            <param name="offset">Offset to start.</param>
            <param name="length">Length to use.</param>
        </member>
        <member name="P:Peach.Core.IO.BitStream.LengthBits">
            <summary>
            Length in bits of buffer
            </summary>
        </member>
        <member name="P:Peach.Core.IO.BitStream.LengthBytes">
            <summary>
            Length in bytes of buffer.  size is
            badded out to 8 bit boundry.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.BitStream.Value">
            <summary>
            Byte array of stream.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.BitStream.Clear">
            <summary>
            Clear contents of stream.  After calling
            position will be 0 and length is also 0.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.BitStream.Clone">
            <summary>
            Create exact copy of this BitStream
            </summary>
            <returns>Returns exact copy of this BitStream</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.TellBits">
            <summary>
            Current position in bits
            </summary>
            <returns>Returns current bit position</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.TellBytes">
            <summary>
            Current position in bytes
            </summary>
            <returns>Returns current byte position</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.SeekBits(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seek to a position in our stream.  We
            will will expand the stream as needed.
            </summary>
            <param name="offset">Offset from origion to seek to</param>
            <param name="origin">Origin to seek from</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.SeekBytes(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Seek to a position in our stream.  We
            will will expand the stream as needed.
            </summary>
            <param name="offset">Offset from origion to seek to</param>
            <param name="origin">Origin to seek from</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.BigEndian">
            <summary>
            Pack/unpack as big endian values.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.BitStream.LittleEndian">
            <summary>
            Pack/unpack as little endian values.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.BitStream.DataElementLength(Peach.Core.Dom.DataElement)">
            <summary>
            Length of DataElement by bits
            </summary>
            <param name="e">DataElement that has already been written to stream</param>
            <returns>Returns size in bits of DataElement</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.DataElementLength(System.String)">
            <summary>
            Length of DataElement by bits
            </summary>
            <param name="fullName">Fullname of DataElement that has already been written to stream</param>
            <returns>Returns size in bits of DataElement</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.DataElementPosition(Peach.Core.Dom.DataElement)">
            <summary>
            position in stream of DataElement
            </summary>
            <param name="e">DataElement that has already been written to the stream</param>
            <returns>Returns bit position of DataElement</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.DataElementPosition(System.String)">
            <summary>
            position in stream of DataElement
            </summary>
            <param name="fullName">DataElement that has already been written to the stream</param>
            <returns>Returns bit position of DataElement</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.MarkStartOfElement(Peach.Core.Dom.DataElement,System.Int64)">
            <summary>
            Mark the starting position of a DataElement in the stream.
            </summary>
            <param name="e">DataElement to mark the position of</param>
            <param name="lengthInBits">Length of DataElement in stream</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.MarkStartOfElement(Peach.Core.Dom.DataElement)">
            <summary>
            Mark the starting position of a DataElement in the stream.
            </summary>
            <param name="e">DataElement to mark the position of</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.MarkEndOfElement(Peach.Core.Dom.DataElement)">
            <summary>
            Mark the ending position of DataElement.  If you have
            already specified a length with MarkStartOfElement you
            do not need to call this method.
            </summary>
            <param name="e">DataElement to mark the position of</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.Write(Peach.Core.IO.BitStream)">
            <summary>
            Write the contents of another BitStream into
            this BitStream.
            </summary>
            <param name="bits">BitStream to write data from.</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.WriteBits(System.UInt64,System.Int32)">
            <summary>
            Write bits using bitfield encoding.
            </summary>
            <param name="value">Value to write</param>
            <param name="bits">Number of bits to write</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.BitLength(System.UInt64)">
            <summary>
            Number of bits required to store value.
            </summary>
            <param name="value">Value to calc bit length of</param>
            <returns>Number of bits required to store number.</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.BitLength(System.UInt64,System.UInt64)">
            <summary>
            Number of bits required to store value
            </summary>
            <param name="value">Value to calc bit length of</param>
            <param name="maxBits">Max length in bits</param>
            <returns>Returns number of bits required to store number.</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.ReadBitsAsBitStream(System.Int64)">
            <summary>
            Read from our stream into a new BitStream.  This call
            is optimized for large reads.
            </summary>
            <param name="bits">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.RealReadBitsAsBitStream(System.Int64)">
            <summary>
            Bit copies are fairly slow.  We need to optimize
            this somehow.
            </summary>
            <param name="bits">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.RealReadBytesAsBitStream(System.Int64)">
            <summary>
            Optimized reading of bytes from our stream.
            </summary>
            <param name="bytes">Number of bytes to copy</param>
            <returns>Returns BitStream instance with our data.</returns>
        </member>
        <member name="M:Peach.Core.IO.BitStream.Truncate">
            <summary>
            Truncate stream from current position.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.BitStream.Truncate(System.Int64)">
            <summary>
            Truncate stream to specific length in bits.
            </summary>
            <param name="sizeInBits">Length in bits of stream</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.Insert(Peach.Core.IO.BitStream)">
            <summary>
            Insert a BitStream at current position.  This
            will cause length of stream to increase by the
            size of "bits".  New position will be after
            inserted "bits".
            </summary>
            <param name="bits">BitStream to insert.</param>
        </member>
        <member name="M:Peach.Core.IO.BitStream.IndexOf(System.Byte[])">
            <summary>
            Locate the first occurance of data and return index.
            </summary>
            <param name="data">Data to search for</param>
            <returns>Returns index or -1 if not found.</returns>
        </member>
        <member name="T:Peach.Core.IO.Conversion.BigEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from big-endian
            byte arrays.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.Conversion.BigEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.Conversion.BigEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.BigEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.BigEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="T:Peach.Core.IO.Conversion.EndianBitConverter">
            <summary>
            Equivalent of System.BitConverter, but with either endianness.
            </summary>
        </member>
        <member name="T:Peach.Core.IO.Conversion.EndianBitConverter.Int32SingleUnion">
            <summary>
            Union used solely for the equivalent of DoubleToInt64Bits and vice versa.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Int32)">
            <summary>
            Creates an instance representing the given integer.
            </summary>
            <param name="i">The integer value of the new instance.</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Single)">
            <summary>
            Creates an instance representing the given floating point number.
            </summary>
            <param name="f">The floating point value of the new instance.</param>
        </member>
        <member name="F:Peach.Core.IO.Conversion.EndianBitConverter.Int32SingleUnion.i">
            <summary>
            Int32 version of the value.
            </summary>
        </member>
        <member name="F:Peach.Core.IO.Conversion.EndianBitConverter.Int32SingleUnion.f">
            <summary>
            Single version of the value.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.Conversion.EndianBitConverter.Int32SingleUnion.AsInt32">
            <summary>
            Returns the value of the instance as an integer.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.Conversion.EndianBitConverter.Int32SingleUnion.AsSingle">
            <summary>
            Returns the value of the instance as a floating point number.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.Conversion.EndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.Conversion.EndianBitConverter.Little">
            <summary>
            Returns a little-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.Conversion.EndianBitConverter.Big">
            <summary>
            Returns a big-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.DoubleToInt64Bits(System.Double)">
            <summary>
            Converts the specified double-precision floating point number to a
            64-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 64-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.Int64BitsToDouble(System.Int64)">
            <summary>
            Converts the specified 64-bit signed integer to a double-precision
            floating point number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A double-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.SingleToInt32Bits(System.Single)">
            <summary>
            Converts the specified single-precision floating point number to a
            32-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 32-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.Int32BitsToSingle(System.Int32)">
            <summary>
            Converts the specified 32-bit signed integer to a single-precision floating point
            number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A single-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToBoolean(System.Byte[],System.Int32)">
            <summary>
            Returns a Boolean value converted from one byte at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>true if the byte at startIndex in value is nonzero; otherwise, false.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToChar(System.Byte[],System.Int32)">
            <summary>
            Returns a Unicode character converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A character formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToDouble(System.Byte[],System.Int32)">
            <summary>
            Returns a double-precision floating point number converted from eight bytes
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A double precision floating point number formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToSingle(System.Byte[],System.Int32)">
            <summary>
            Returns a single-precision floating point number converted from four bytes
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A single precision floating point number formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit signed integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit signed integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit signed integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit signed integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit signed integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit signed integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToUInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit unsigned integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit unsigned integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToUInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit unsigned integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit unsigned integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToUInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit unsigned integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit unsigned integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CheckByteArgument(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the given argument for validity.
            </summary>
            <param name="value">The byte array passed in</param>
            <param name="startIndex">The start index passed in</param>
            <param name="bytesRequired">The number of bytes required</param>
            <exception cref="T:System.ArgumentNullException">value is a null reference</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            startIndex is less than zero or greater than the length of value minus bytesRequired.
            </exception>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CheckedFromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the arguments for validity before calling FromBytes
            (which can therefore assume the arguments are valid).
            </summary>
            <param name="value">The bytes to convert after checking</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to convert</param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert the given number of bytes from the given array, from the given start
            position, into a long, using the bytes as the least significant part of the long.
            By the time this is called, the arguments have been checked for validity.
            </summary>
            <param name="value">The bytes to convert</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to use in the conversion</param>
            <returns>The converted number</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToString(System.Byte[])">
            <summary>
            Returns a String converted from the elements of a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <remarks>All the elements of value are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32)">
            <summary>
            Returns a String converted from the elements of a byte array starting at a specified array position.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <remarks>The elements from array position startIndex to the end of the array are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a String converted from a specified number of bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <param name="length">The number of bytes to convert.</param>
            <remarks>The length elements from array position startIndex are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.ToDecimal(System.Byte[],System.Int32)">
            <summary>
            Returns a decimal value converted from sixteen bytes
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A decimal  formed by sixteen bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Decimal)">
            <summary>
            Returns the specified decimal value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 16.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Decimal,System.Byte[],System.Int32)">
            <summary>
            Copies the specified decimal value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Int64,System.Int32)">
            <summary>
            Returns an array with the given number of bytes formed
            from the least significant bytes of the specified value.
            This is used to implement the other GetBytes methods.
            </summary>
            <param name="value">The value to get bytes for</param>
            <param name="bytes">The number of significant bytes to return</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Boolean)">
            <summary>
            Returns the specified Boolean value as an array of bytes.
            </summary>
            <param name="value">A Boolean value.</param>
            <returns>An array of bytes with length 1.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Char)">
            <summary>
            Returns the specified Unicode character value as an array of bytes.
            </summary>
            <param name="value">A character to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Double)">
            <summary>
            Returns the specified double-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Int16)">
            <summary>
            Returns the specified 16-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Int32)">
            <summary>
            Returns the specified 32-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Int64)">
            <summary>
            Returns the specified 64-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.Single)">
            <summary>
            Returns the specified single-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.UInt16)">
            <summary>
            Returns the specified 16-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.UInt32)">
            <summary>
            Returns the specified 32-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.GetBytes(System.UInt64)">
            <summary>
            Returns the specified 64-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This is used to implement the other CopyBytes methods.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This must be implemented in concrete derived classes, but the implementation
            may assume that the value will fit into the buffer.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Boolean value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A Boolean value.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Char,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Unicode character value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Double,System.Byte[],System.Int32)">
            <summary>
            Copies the specified double-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Int16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.Single,System.Byte[],System.Int32)">
            <summary>
            Copies the specified single-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.EndianBitConverter.CopyBytes(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="T:Peach.Core.IO.Conversion.Endianness">
            <summary>
            Endianness of a converter
            </summary>
        </member>
        <member name="F:Peach.Core.IO.Conversion.Endianness.LittleEndian">
            <summary>
            Little endian - least significant byte first
            </summary>
        </member>
        <member name="F:Peach.Core.IO.Conversion.Endianness.BigEndian">
            <summary>
            Big endian - most significant byte first
            </summary>
        </member>
        <member name="T:Peach.Core.IO.Conversion.LittleEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from little-endian
            byte arrays.
            </summary>
        </member>
        <member name="P:Peach.Core.IO.Conversion.LittleEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="M:Peach.Core.IO.Conversion.LittleEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:Peach.Core.IO.Conversion.LittleEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:Peach.Core.IO.Conversion.LittleEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="T:Peach.Core.IWeighted">
            <summary>
            Weight to use on random selection.
            </summary>
        </member>
        <member name="P:Peach.Core.IWeighted.SelectionWeight">
            <summary>
            Selection weight used for weighted selection.
            </summary>
        </member>
        <member name="T:Peach.Core.LSFR">
            <summary>
            Linear Shift Feedback Register
            Produces a pseudo random sequence of numbers from 1 to (2^N)-1
            </summary>
        </member>
        <member name="T:Peach.Core.SequenceGenerator">
            <summary>
            Produces a pseudo random sequence of numbers from [1,max]
            </summary>
        </member>
        <member name="T:Peach.Core.Logger">
            <summary>
            Base class for different logging methods.
            </summary>
        </member>
        <member name="T:Peach.Core.LoggerAttribute">
            <summary>
            Used to indicate a class is a valid Publisher and
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Loggers.FileLogger">
            <summary>
            Standard file system logger.
            </summary>
        </member>
        <member name="F:Peach.Core.MutationStrategies.RandomStrategy._iteration">
            <summary>
            container also contains states if we have mutations
            we can apply to them.  State names are prefixed with "STATE_" to avoid
            conflicting with data model names.
            Use a list to maintain the order this strategy learns about data models
            </summary>
        </member>
        <member name="F:Peach.Core.MutationStrategies.RandomStrategy.switchCount">
            <summary>
            How often to switch files.
            </summary>
        </member>
        <member name="F:Peach.Core.MutationStrategies.RandomStrategy.maxFieldsToMutate">
            <summary>
            Maximum number of fields to mutate at once.
            </summary>
        </member>
        <member name="M:Peach.Core.MutationStrategies.RandomStrategy.MutateChangingState(Peach.Core.Dom.State)">
            <summary>
            Allows mutation strategy to affect state change.
            </summary>
            <param name="state">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.MutationStrategies.Sequential.MutateChangingState(Peach.Core.Dom.State)">
            <summary>
            Allows mutation strategy to affect state change.
            </summary>
            <param name="state">
            </param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.MutationStrategy">
            <summary>
            Mutation strategies drive the fuzzing
            that Peach performs.  Creating a fuzzing
            strategy allows one to fully control which elements
            are mutated, by which mutators, and when.
            </summary>
        </member>
        <member name="M:Peach.Core.MutationStrategy.MutateChangingState(Peach.Core.Dom.State)">
            <summary>
            Allows mutation strategy to affect state change.
            </summary>
            <param name="state">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.MutationStrategy.SupportedDataElement(System.Type,Peach.Core.Dom.DataElement)">
            <summary>
            Call supportedDataElement method on Mutator type.
            </summary>
            <param name="mutator">
            </param>
            <param name="elem">
            </param>
            <returns>Returns true or false</returns>
        </member>
        <member name="M:Peach.Core.MutationStrategy.SupportedState(System.Type,Peach.Core.Dom.State)">
            <summary>
            Call supportedDataElement method on Mutator type.
            </summary>
            <param name="mutator">
            </param>
            <param name="elem">
            </param>
            <returns>Returns true or false</returns>
        </member>
        <member name="M:Peach.Core.MutationStrategy.EnumerateValidMutators">
            <summary>
            Enumerate mutators valid to use in this test.
            </summary>
            <remarks>
            Function checks against included/exluded mutators list.
            </remarks>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.Mutator">
            <summary>
            Base class for Mutators.
            </summary>
        </member>
        <member name="F:Peach.Core.Mutator.context">
            <summary>
            Instance of current mutation strategy
            </summary>
        </member>
        <member name="F:Peach.Core.Mutator.weight">
            <summary>
            Weight this mutator will get chosen in random mutation mode.
            </summary>
        </member>
        <member name="F:Peach.Core.Mutator.name">
            <summary>
            Name of this mutator
            </summary>
        </member>
        <member name="P:Peach.Core.Mutator.count">
            <summary>
            Returns the total number of mutations this
            mutator is able to perform.
            </summary>
            <returns>Returns number of mutations mutater can generate.</returns>
        </member>
        <member name="M:Peach.Core.Mutator.supportedDataElement(Peach.Core.Dom.DataElement)">
            <summary>
            Check to see if DataElement is supported by this
            mutator.
            </summary>
            <param name="obj">DataElement to check</param>
            <returns>True if object is supported, else False</returns>
        </member>
        <member name="M:Peach.Core.Mutator.supportedState(Peach.Core.Dom.State)">
            <summary>
            Check to see if State is supported by this
            mutator.
            </summary>
            <param name="obj">State to check</param>
            <returns>True if object is supported, else False</returns>
        </member>
        <member name="M:Peach.Core.Mutator.sequentialMutation(Peach.Core.Dom.DataElement)">
            <summary>
            Perform a sequential mutation.
            </summary>
            <param name="obj">
            </param>
        </member>
        <member name="M:Peach.Core.Mutator.randomMutation(Peach.Core.Dom.DataElement)">
            <summary>
            Perform a random mutation.
            </summary>
            <param name="obj">
            </param>
        </member>
        <member name="M:Peach.Core.Mutator.changeState(Peach.Core.Dom.State)">
            <summary>
            Allow changing which state we change to.
            </summary>
            <param name="obj">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Mutators.StringCaseMutator.Sample(System.Int32)">
            <summary>
            Return a sampling of indexes based on max index.
            </summary>
            <remarks>
            For indexes &lt; 20 we return all indexes.  When
            over 20 we return a max of 20 samples.
            </remarks>
            <param name="max">Max index</param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.NetworkAdapter">
            <summary>
            Helper class to control properties of a network adapter.
            </summary>
        </member>
        <member name="M:Peach.Core.ParameterParser.Parse``1(``0,System.Collections.Generic.Dictionary{System.String,Peach.Core.Variant})">
            <summary>
            Parses a dictionary of arguments, similiar to python kwargs.
            For each parameter attribute on 'T', the appropriate property
            on 'obj' will be set. Eg, given integer parameter 'option1':
            obj.option1 = int.Parse(args["option1"])
            </summary>
            <typeparam name="T">Class type</typeparam>
            <param name="obj">Instance of class T</param>
            <param name="args">Dictionary of arguments</param>
        </member>
        <member name="M:Peach.Core.ParameterParser.FromString(System.Type,Peach.Core.ParameterAttribute,System.String)">
            <summary>
            Will convert a string value to the type described in the ParameterAttribute.
            If an appropriate conversion function can not be found, this function will
            look for a static method on 'type' to perform the conversion.  For example,
            if the attribute type was class 'SomeClass', the function signature would be:
            static void Parse(string str, out SomeClass val)
            If the value is string.Empty and the destination type is nullable, the value
            null will be returned.
            </summary>
            <param name="type">Object type that is decorated with the Parameter attribute.</param>
            <param name="attr">Parameter attribute describing the destination type.</param>
            <param name="value">String value to convert.</param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.PeachException">
            <summary>
            Unrecoverable error.  Causes Peach to exit with an error
            message, but no stack trace.
            </summary>
        </member>
        <member name="T:Peach.Core.RedoIterationException">
            <summary>
            Thrown to cause the Peach Engine to re-run
            the same test iteration.
            </summary>
        </member>
        <member name="T:Peach.Core.SoftException">
            <summary>
            Thrown to stop current iteration and move to next.
            </summary>
        </member>
        <member name="T:Peach.Core.PathException">
            <summary>
            Similar to SoftException but used by state model
            path code.
            </summary>
        </member>
        <member name="T:Peach.Core.AgentException">
            <summary>
            Thrown when peach catches an exception from an agent.
            </summary>
        </member>
        <member name="T:Peach.Core.PitParsableAttribute">
            <summary>
            Indicate a class implements methods required
            to support PIT Parsing.
            </summary>
            <remarks>
            Any type that is marked with this attribute must implement
            the following methods:
            public static DataElement PitParser(PitParser context, XmlNode node, DataElementContainer parent)
            If unable to parse the current XML, just return null.
            </remarks>
        </member>
        <member name="M:Peach.Core.PitParsableAttribute.#ctor(System.String)">
            <summary>
            Indicate a class implements methods required
            to support PIT Parsing.
            </summary>
            <param name="xmlElementName">XML element name that corresponds to this type.</param>
        </member>
        <member name="F:Peach.Core.PitParsableAttribute.xmlElementName">
            <summary>
            XML element name that corresponds to this type.
            </summary>
        </member>
        <member name="T:Peach.Core.Platform">
            <summary>
            Helper class to determine the OS/Platform we are on.  The built in
            method returns incorrect results.
            </summary>
        </member>
        <member name="T:Peach.Core.IProcessInfo">
            <summary>
            Helper class to get information on a process.  The built in
            methods on mono aren't 100% implemented.
            </summary>
        </member>
        <member name="M:Peach.Core.IProcessInfo.Snapshot(System.Diagnostics.Process)">
            <summary>
            Returns a populated ProcessInfo instance.
            throws ArgumentException if the Process is not valid.
            </summary>
            <param name="p">Process to obtain info about.</param>
            <returns>Information about the process.</returns>
        </member>
        <member name="T:Peach.Core.Proxy.Connection">
            <summary>
            A socker par (client/server)
            </summary>
        </member>
        <member name="T:Peach.Core.Proxy.WorkHandler">
            <summary>
            Delagete for consumer to perform work items.  Client should not perform
            long running tasks in this handler as it will block proxy operation.
            </summary>
            <returns>Return false to exit proxy.</returns>
        </member>
        <member name="M:Peach.Core.Proxy.Proxy.#ctor(System.String,System.Int32)">
            <summary>
            Create a proxy instance.
            </summary>
            <param name="address">To listen on all interaces specify 0.0.0.0 as the address (the default)</param>
            <param name="port">Port to listen on, default is 8080.</param>
        </member>
        <member name="M:Peach.Core.Proxy.Web.HttpCookie.Parse(System.String)">
            <summary>
            Parse a cookie string into a cookie class
            </summary>
            <param name="data">String containing single cookie</param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.Publisher">
            <summary>
            Publishers are I/O interfaces for Peach.  They glue the actions
            in a state model to the target interface.  Publishers can be
            stream based such as files or sockets, and also call based like
            COM and shared libraries.  They can also be hybrids using both
            stream and call based methods to make more complex publishers.
            Multiple publishers can be used in a single state model to allow
            for more complex opertions such as writeing to the registry and
            then calling an RPC method.
            </summary>
        </member>
        <member name="P:Peach.Core.Publisher.Test">
            <summary>
            The top level test object.
            </summary>
        </member>
        <member name="P:Peach.Core.Publisher.Iteration">
            <summary>
            Gets/sets the current fuzzing iteration.
            </summary>
        </member>
        <member name="P:Peach.Core.Publisher.IsControlIteration">
            <summary>
            Gets/sets if the current iteration is a control iteration.
            </summary>
        </member>
        <member name="P:Peach.Core.Publisher.Result">
            <summary>
            Get the result value (if any).
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.OnStart">
            <summary>
            Called when the publisher is started.  This method will be called
            once per fuzzing "Session", not on every iteration.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.OnStop">
            <summary>
            Called when the publisher is stopped.  This method will be called
            once per fuzzing "Session", not on every iteration.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.OnOpen">
            <summary>
            Open or connect to a resource.  Will be called
            automatically if not called specifically.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.OnClose">
            <summary>
            Close a resource.  Will be called automatically when
            state model exists.  Can also be called explicitly when
            needed.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.OnAccept">
            <summary>
            Accept an incoming connection.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.OnCall(System.String,System.Collections.Generic.List{Peach.Core.Dom.ActionParameter})">
            <summary>
            Call a method on the Publishers resource
            </summary>
            <param name="method">Name of method to call</param>
            <param name="args">Arguments to pass</param>
            <returns>Returns resulting data</returns>
        </member>
        <member name="M:Peach.Core.Publisher.OnSetProperty(System.String,Peach.Core.Variant)">
            <summary>
            Set a property on the Publishers resource.
            </summary>
            <param name="property">Name of property to set</param>
            <param name="value">Value to set on property</param>
        </member>
        <member name="M:Peach.Core.Publisher.OnGetProperty(System.String)">
            <summary>
            Get value of a property exposed by Publishers resource
            </summary>
            <param name="property">Name of property</param>
            <returns>Returns value of property</returns>
        </member>
        <member name="M:Peach.Core.Publisher.OnOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send data
            </summary>
            <param name="buffer">Data to send/write</param>
            <param name="offset">The byte offset in buffer at which to begin writing from.</param>
            <param name="count">The maximum number of bytes to write.</param>
        </member>
        <member name="M:Peach.Core.Publisher.OnInput">
            <summary>
            Read data
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.start">
            <summary>
            Called to Start publisher.  This action is always performed
            even if not specifically called.  This method will be called
            once per fuzzing "Session", not on every iteration.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.stop">
            <summary>
            Called to Stop publisher.  This action is always performed
            even if not specifically called.  This method will be called
            once per fuzzing "Session", not on every iteration.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.accept">
            <summary>
            Accept an incoming connection.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.open">
            <summary>
            Open or connect to a resource.  Will be called
            automatically if not called specifically.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.close">
            <summary>
            Close a resource.  Will be called automatically when
            state model exists.  Can also be called explicitly when
            needed.
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.call(System.String,System.Collections.Generic.List{Peach.Core.Dom.ActionParameter})">
            <summary>
            Call a method on the Publishers resource
            </summary>
            <param name="method">Name of method to call</param>
            <param name="args">Arguments to pass</param>
            <returns>Returns resulting data</returns>
        </member>
        <member name="M:Peach.Core.Publisher.setProperty(System.String,Peach.Core.Variant)">
            <summary>
            Set a property on the Publishers resource.
            </summary>
            <param name="property">Name of property to set</param>
            <param name="value">Value to set on property</param>
        </member>
        <member name="M:Peach.Core.Publisher.getProperty(System.String)">
            <summary>
            Get value of a property exposed by Publishers resource
            </summary>
            <param name="property">Name of property</param>
            <returns>Returns value of property</returns>
        </member>
        <member name="M:Peach.Core.Publisher.output(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send data
            </summary>
            <param name="buffer">Data to send/write</param>
            <param name="offset">The byte offset in buffer at which to begin writing from.</param>
            <param name="count">The maximum number of bytes to write.</param>
        </member>
        <member name="M:Peach.Core.Publisher.input">
            <summary>
            Read data
            </summary>
        </member>
        <member name="M:Peach.Core.Publisher.WantBytes(System.Int64)">
            <summary>
            Blocking stream based publishers override this to wait
            for a certian amount of bytes to be available for reading.
            </summary>
            <param name="count">The requested byte count</param>
        </member>
        <member name="T:Peach.Core.PublisherAttribute">
            <summary>
            Used to indicate a class is a valid Publisher and
            provide it's invoking name used in the Pit XML file.
            </summary>
        </member>
        <member name="T:Peach.Core.Publishers.BufferedStreamPublisher">
            <summary>
            Helper class for creating stream based publishers.
            This class is used when the publisher implementation
            has a non-seekable stream interface.
            Most derived classes should only need to override OnOpen()
            and in the implementation open _client and call StartClient()
            to begin async reads from _client to _buffer.
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.HttpPublisher.OnOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send data
            </summary>
            <param name="buffer">Data to send/write</param>
            <param name="offset">The byte offset in buffer at which to begin writing from.</param>
            <param name="count">The maximum number of bytes to write.</param>
        </member>
        <member name="T:Peach.Core.Publishers.RawV4Publisher">
            <summary>
            Allows for input/output of raw IP packets.
            Protocol is the IP protocol number to send/receive.
            This publisher does not expect an IP header in the output buffer.
            The IP header is always included in the input buffer.
            </summary>
            <remarks>
            Mac raw sockets don't support TCP or UDP receptions.
            See the "b. FreeBSD" section at: http://sock-raw.org/papers/sock_raw
            </remarks>
        </member>
        <member name="T:Peach.Core.Publishers.RawIPv4Publisher">
            <summary>
            Allows for input/output of raw IP packets.
            Protocol is the IP protocol number to send/receive.
            This publisher expects an IP header in the output buffer.
            The IP header is always included in the input buffer.
            </summary>
            <remarks>
            Mac raw sockets don't support TCP or UDP receptions.
            See the "b. FreeBSD" section at: http://sock-raw.org/papers/sock_raw
            </remarks>
        </member>
        <member name="T:Peach.Core.Publishers.RawV6Publisher">
            <summary>
            Allows for input/output of raw IP packets.
            Protocol is the IP protocol number to send/receive.
            This publisher does not expect an IP header in the output buffer.
            The IP header is always included in the input buffer.
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.RemotePublisher.PerformRemoting(System.Threading.ThreadStart)">
            <summary>
            Perform our remoting call with a forced timeout.
            </summary>
            <param name="method">
            </param>
        </member>
        <member name="M:Peach.Core.Publishers.SocketPublisher.GetScopeId(System.Net.IPAddress)">
            <summary>
            Resolves the ScopeId for a Link-Local IPv6 address
            </summary>
            <param name="ip">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Publishers.SocketPublisher.GetLocalIp(System.Net.IPEndPoint)">
            <summary>
            Returns the local ip that should be used to talk to 'remote'
            </summary>
            <param name="remote">
            </param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.Publishers.StreamPublisher">
            <summary>
            Helper class for creating stream based publishers.
            Derived classes should only need to override OnOpen and OnClose
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.WebServiceInvoker.#ctor(System.Uri)">
            <summary>
            Creates the service invoker using the specified web service.
            </summary>
            <param name="webServiceUri">
            </param>
        </member>
        <member name="P:Peach.Core.Publishers.WebServiceInvoker.AvailableServices">
            <summary>
            Text description of the available services within this web service.
            </summary>
        </member>
        <member name="M:Peach.Core.Publishers.WebServiceInvoker.EnumerateServiceMethods(System.String)">
            <summary>
            Gets a list of all methods available for the specified service.
            </summary>
            <param name="serviceName">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Publishers.WebServiceInvoker.InvokeMethod``1(System.String,System.String,System.Object[])">
            <summary>
            Invokes the specified method of the named service.
            </summary>
            <typeparam name="T">The expected return type.</typeparam>
            <param name="serviceName">The name of the service to use.</param>
            <param name="methodName">The name of the method to call.</param>
            <param name="args">The arguments to the method.</param>
            <returns>The return value from the web service method.</returns>
        </member>
        <member name="M:Peach.Core.Publishers.WebServiceInvoker.BuildServiceDescriptionImporter(System.String)">
            <summary>
            Builds the web service description importer, which allows us to generate a proxy class based on the
            content of the WSDL described by the XmlTextReader.
            </summary>
            <param name="webserviceUri">The WSDL content, described by XML.</param>
            <returns>A ServiceDescriptionImporter that can be used to create a proxy class.</returns>
        </member>
        <member name="M:Peach.Core.Publishers.WebServiceInvoker.CompileAssembly(System.Web.Services.Description.ServiceDescriptionImporter)">
            <summary>
            Compiles an assembly from the proxy class provided by the ServiceDescriptionImporter.
            </summary>
            <param name="descriptionImporter">
            </param>
            <returns>An assembly that can be used to execute the web service methods.</returns>
        </member>
        <member name="M:Peach.Core.Publishers.WebServiceInvoker.BuildAssemblyFromWSDL(System.Uri)">
            <summary>
            Builds an assembly from a web service description.
            The assembly can be used to execute the web service methods.
            </summary>
            <param name="webServiceUri">Location of WSDL.</param>
            <returns>A web service assembly.</returns>
        </member>
        <member name="M:Peach.Core.Random.Shuffle``1(``0[])">
            <summary>
            Fisher-Yates array shuffling algorithm.
            </summary>
            <typeparam name="T">
            </typeparam>
            <param name="items">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Random.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Work around for missing method in Mono
            </summary>
            <typeparam name="T">
            </typeparam>
            <param name="list">
            </param>
            <param name="index">
            </param>
            <returns>
            </returns>
        </member>
        <member name="T:Peach.Core.RunConfiguration">
            <summary>
            Configure the current run
            </summary>
        </member>
        <member name="T:Peach.Core.RunConfiguration.StopHandler">
            <summary>
            Function that returns true if the engine should stop
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.countOnly">
            <summary>
            Just get the count of mutations
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.singleIteration">
            <summary>
            Perform a single iteration
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.range">
            <summary>
            Specify the test range to perform
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.parallel">
            <summary>
            Controls parallel fuzzing
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.skipToIteration">
            <summary>
            Skip to a specific iteration
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.debug">
            <summary>
            Enable or disable debugging output
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.strategy">
            <summary>
            Fuzzing strategy to use
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.runName">
            <summary>
            Name of run to perform
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.pitFile">
            <summary>
            Name of PIT file (used by logger)
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.commandLine">
            <summary>
            Command line if any (used by logger)
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.runDateTime">
            <summary>
            Date and time of run (used by logger)
            </summary>
        </member>
        <member name="F:Peach.Core.RunConfiguration.randomSeed">
            <summary>
            Random number generator SEED
            </summary>
            <remarks>
            If the same SEED value is specified the same
            iterations will be performed with same values.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunConfiguration.shouldStop">
            <summary>
            Called every iteration by the engine to check if it should stop
            </summary>
        </member>
        <member name="P:Peach.Core.RunConfiguration.version">
            <summary>
            Peach version currently running (used by logger)
            </summary>
        </member>
        <member name="T:Peach.Core.RunContext">
            <summary>
            Contains state information regarding the current fuzzing run.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.config">
            <summary>
            Configuration settings for this run
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.engine">
            <summary>
            Engine instance for this run
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.dom">
            <summary>
            Dom to use for this run
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.test">
            <summary>
            Current test being run
            </summary>
            <remarks>
            Currently the Engine code sets this.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.agentManager">
            <summary>
            Current agent manager for this run.
            </summary>
            <remarks>
            Currently the Engine code sets this.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.stateStore">
            <summary>
            An object store that will last entire run.  For use
            by Peach code to store some state.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.iterationStateStore">
            <summary>
            An object store that will last current iteration.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.controlIteration">
            <summary>
            Is this a control iteration.  Control iterations are used
            to verify the system can still reliably fuzz and are performed
            with out any mutations applied.
            </summary>
            <remarks>
            The first iteration is a special control iteration.  We also
            perform control iterations after we have collected a fault.
            In later version we will likely inject control iterations every
            N iterations where N is &gt;= 100.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.controlRecordingIteration">
            <summary>
            Is this control operation also a recording iteration?
            </summary>
            <remarks>
            Recording iterations set our controlActionsExecuted and
            controlStatesExecuted arrays.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.controlRecordingActionsExecuted">
            <summary>
            Actions performed during first control iteration.  Used to validate
            control iterations that come later have same action coverage.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.controlRecordingStatesExecuted">
            <summary>
            States performed during first control iteration.  Used to validate
            control iterations that come later have same state coverage.
            </summary>
            <remarks>
            This may not be required with action coverage.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.controlActionsExecuted">
            <summary>
            Actions performed during later control iterations.  Used to validate
            control iterations that come later have same action coverage.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.controlStatesExecuted">
            <summary>
            States performed during later control iterations.  Used to validate
            control iterations that come later have same state coverage.
            </summary>
            <remarks>
            This may not be required with action coverage.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.faults">
            <summary>
            Faults for current iteration of fuzzing.  This collection
            is cleared after each iteration.
            </summary>
            <remarks>
            This collection should only be added to from the CollectFaults event.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext._continueFuzzing">
            <summary>
            Controls if we continue fuzzing or exit
            after current iteration.  This can be used
            by UI code to stop Peach.
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingFault">
            <summary>
            True when we have found a fault and are in the process
            of reproducing it.
            </summary>
            <remarks>
            Many times, especially with network fuzzing, the iteration we detect a fault on is not the
            correct iteration, or the fault requires multiple iterations to reproduce.
            Peach will start reproducing at the current iteration count then start moving backwards
            until we locate the iteration causing the crash, or reach our max back search value.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingMaxBacksearch">
            <summary>
            Number of iteration to search backwards trying to reproduce a fault.
            </summary>
            <remarks>
            Many times, especially with network fuzzing, the iteration we detect a fault on is not the
            correct iteration, or the fault requires multiple iterations to reproduce.
            Peach will start reproducing at the current iteration count then start moving backwards
            until we locate the iteration causing the crash, or reach our max back search value.
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingInitialIteration">
            <summary>
            The initial iteration we detected fault on
            </summary>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingSkipMultiple">
            <summary>
            This value times current iteration change is next iteration change.
            </summary>
            <remarks>
            Intial search process:
            Move back 1
            Move back 1 * reproducingSkipMultiple = N
            Move back N * reproducingSkipMultiple = M
            Move back M * reproducingSkipMultiple = O
            Move back O * reproducingSkipMultiple ...
            </remarks>
        </member>
        <member name="F:Peach.Core.RunContext.reproducingIterationJumpCount">
            <summary>
            Number of iterations to jump.
            </summary>
            <remarks>
            Initializes to 1, then multiply against reproducingSkipMultiple
            </remarks>
        </member>
        <member name="E:Peach.Core.RunContext.CollectFaults">
            <summary>
            This event is triggered after an interation has occured to allow
            collection of faults into RunContext.faults collection.
            </summary>
        </member>
        <member name="T:Peach.Core.FaultType">
            <summary>
            Type of fault
            </summary>
        </member>
        <member name="T:Peach.Core.Fault">
            <summary>
            Fault detected during fuzzing run
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.iteration">
            <summary>
            Iteration fault was detected on
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.controlIteration">
            <summary>
            Is this a control iteration.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.controlRecordingIteration">
            <summary>
            Is this control operation also a recording iteration?
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.type">
            <summary>
            Type of fault
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.detectionSource">
            <summary>
            Who detected this fault?
            </summary>
            <remarks>
            Example: "PageHeap Monitor"
            Example: "Name (PageHeap Monitor)"
            </remarks>
        </member>
        <member name="F:Peach.Core.Fault.title">
            <summary>
            Title of finding
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.description">
            <summary>
            Multiline description and collection of information.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.majorHash">
            <summary>
            Major hash of fault used for bucketting.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.minorHash">
            <summary>
            Minor hash of fault used for bucketting.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.exploitability">
            <summary>
            Exploitability of fault, used for bucketting.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.folderName">
            <summary>
            Folder for fault to be collected under.  Only used when
            major/minor hashes and exploitability are not defined.
            </summary>
        </member>
        <member name="F:Peach.Core.Fault.collectedData">
            <summary>
            Binary data collected about fault.  Key is filename, value is content.
            </summary>
        </member>
        <member name="T:Peach.Core.Runtime.Program">
            <summary>
            Command line interface for Peach 3.  Mostly backwards compatable with
            Peach 2.3.
            </summary>
        </member>
        <member name="P:Peach.Core.Runtime.Program.Copyright">
            <summary>
            Copyright message
            </summary>
        </member>
        <member name="P:Peach.Core.Runtime.Program.ProductName">
            <summary>
            Product name
            </summary>
        </member>
        <member name="P:Peach.Core.Runtime.Program.ErrorOnArchitecture">
            <summary>
            Error on 64 vs 32bit missmatch? Override to change.
            </summary>
        </member>
        <member name="M:Peach.Core.Runtime.Program.AddCustomOptions(Peach.Core.Runtime.OptionSet)">
            <summary>
            Override to add custom options
            </summary>
            <param name="options">
            </param>
        </member>
        <member name="M:Peach.Core.Runtime.Program.Syntax">
            <summary>
            Override to change syntax message.
            </summary>
        </member>
        <member name="T:Peach.Core.Scripting">
            <summary>
            Scripting class provides easy to use
            methods for using Python/Ruby with Peach.
            </summary>
        </member>
        <member name="T:Peach.Core.Transformer">
            <summary>
            Transformers perform static transforms of data.
            </summary>
        </member>
        <member name="M:Peach.Core.Transformer.encode(Peach.Core.IO.BitStream)">
            <summary>
            Encode data, will properly call any chained transformers.
            </summary>
            <param name="data">Data to encode</param>
            <returns>Returns encoded value or null if encoding is not supported.</returns>
        </member>
        <member name="M:Peach.Core.Transformer.decode(Peach.Core.IO.BitStream)">
            <summary>
            Decode data, will properly call any chained transformers.
            </summary>
            <param name="data">Data to decode</param>
            <returns>Returns decoded value or null if decoding is not supported.</returns>
        </member>
        <member name="M:Peach.Core.Transformer.internalEncode(Peach.Core.IO.BitStream)">
            <summary>
            Implement to perform actual encoding of
            data.
            </summary>
            <param name="data">Data to encode</param>
            <returns>Returns encoded data</returns>
        </member>
        <member name="M:Peach.Core.Transformer.internalDecode(Peach.Core.IO.BitStream)">
            <summary>
            Implement to perform actual decoding of
            data.
            </summary>
            <param name="data">Data to decode</param>
            <returns>Returns decoded data</returns>
        </member>
        <member name="T:Peach.Core.TransformerAttribute">
            <summary>
            Use this attribute to identify Transformers
            </summary>
        </member>
        <member name="T:Peach.Core.Transformers.Crypto.UnixCryptTool">
            <summary>
            Provides the Unix crypt() encryption algorithm.
            </summary>
        </member>
        <member name="F:Peach.Core.Transformers.Crypto.UnixCryptTool.m_encryptionSaltCharacters">
            <value>
            The list with characters allowed in a Unix encrypted password.
            It is used to randomly chose two characters for use in the encryption.
            </value>
        </member>
        <member name="F:Peach.Core.Transformers.Crypto.UnixCryptTool.m_desIterations">
            <value>
            Marks the size of the dynamically created schedule lookup-table.
            </value>
        </member>
        <member name="F:Peach.Core.Transformers.Crypto.UnixCryptTool.m_saltTranslation">
            <value>
            A lookup-table, presumably filled with some sort of encryption key.
            It is used to calculate the index to the m_SPTranslationTable lookup-table.
            </value>
        </member>
        <member name="F:Peach.Core.Transformers.Crypto.UnixCryptTool.m_shifts">
            <value>
            A lookup-table.
            It is used to calculate the index to the m_skb lookup-table.
            </value>
        </member>
        <member name="F:Peach.Core.Transformers.Crypto.UnixCryptTool.m_skb">
            <value>
            A lookup-table.
            It is used the dynamically create the schedule lookup-table.
            </value>
        </member>
        <member name="F:Peach.Core.Transformers.Crypto.UnixCryptTool.m_SPTranslationTable">
            <value>
            A lookup-table.
            It is used to calculate two ints that are used to encrypt the password.
            </value>
        </member>
        <member name="F:Peach.Core.Transformers.Crypto.UnixCryptTool.m_characterConversionTable">
            <value>
            A lookup-table filled with printable characters.
            It is used to make sure the encrypted password contains only printable characters. It is filled with
            ASCII characters 46 - 122 (from the dot (.) untill (including) the lowercase 'z').
            </value>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.FourBytesToInt(System.Byte[],System.UInt32)">
            <summary>
            Converts four seperate bytes into one uint.
            </summary>
            <param name="inputBytes">The bytes to use for the conversion.</param>
            <param name="offset">The offset at which to start in the inputBytes buffer.</param>
            <returns>
            </returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.IntToFourBytes(System.UInt32,System.Byte[],System.UInt32)">
            <summary>
            Converts an uint into 4 seperate bytes.
            </summary>
            <param name="inputInt">The uint to convert.</param>
            <param name="outputBytes">The byte buffer into which to store the result.</param>
            <param name="offset">The offset to start storing at in the outputBytes buffer.</param>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.PermOperation(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
            <summary>
            Performs some operation on 4 uints. It's labeled PERM_OP in the original source.
            </summary>
            <param name="firstInt">The first uint to use.</param>
            <param name="secondInt">The second uint to use.</param>
            <param name="thirdInt">The third uint to use.</param>
            <param name="fourthInt">The fourth uint to use.</param>
            <param name="operationResults">An array of 2 uints that are the result of this operation.</param>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.HPermOperation(System.UInt32,System.Int32,System.UInt32)">
            <summary>
            Performs some operation on 3 uints. It's labeled HPERM_OP in the original source.
            </summary>
            <param name="firstInt">The first uint to use.</param>
            <param name="secondInt">The second int to use.</param>
            <param name="thirdInt">The third uint to use.</param>
            <returns>An int that is the result of this operation.</returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.SetDESKey(System.Byte[])">
            <summary>
            This method does some very complex bit manipulations.
            </summary>
            <param name="encryptionKey">The input data to use for the bit manipulations.</param>
            <returns>m_desIterations * 2 number of uints that are the result of the manipulations.</returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.DEncrypt(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
            <summary>
            This method does some bit manipulations.
            </summary>
            <param name="left">An input that is manipulated and then used for output.</param>
            <param name="right">This is used for the bit manipulation.</param>
            <param name="scheduleIndex">The index of an uint to use from the schedule array.</param>
            <param name="firstSaltTranslator">The translated salt for the first salt character.</param>
            <param name="secondSaltTranslator">The translated salt for the second salt character.</param>
            <param name="schedule">The schedule arrray calculated before.</param>
            <returns>The result of these manipulations.</returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.Body(System.UInt32[],System.UInt32,System.UInt32)">
            <summary>
            Calculates two uints that are used to encrypt the password.
            </summary>
            <param name="schedule">The schedule table calculated earlier.</param>
            <param name="firstSaltTranslator">The first translated salt character.</param>
            <param name="secondSaltTranslator">The second translated salt character.</param>
            <returns>2 uints in an array.</returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.Crypt(System.String)">
            <summary>
            Automatically generate the encryption salt (2 random printable characters for use in the encryption) and call the Crypt() method.
            </summary>
            <param name="textToEncrypt">The text that must be encrypted.</param>
            <returns>The encrypted text.</returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixCryptTool.Crypt(System.String,System.String)">
            <summary>
            Encrypts the specified string using the Unix crypt algorithm.
            </summary>
            <param name="encryptionSalt">2 random printable characters that are used to randomize the encryption.</param>
            <param name="textToEncrypt">The text that must be encrypted.</param>
            <returns>The encrypted text.</returns>
        </member>
        <member name="F:Peach.Core.Transformers.Crypto.UnixMd5CryptTool.itoa64">
             Characters for base64 encoding</member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixMd5CryptTool.Concat(System.Byte[],System.Byte[])">
            <summary>
            A function to concatenate bytes[]
            </summary>
            <param name="array1">
            </param>
            <param name="array2">
            </param>
            <returns>New adition array</returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixMd5CryptTool.PartialConcat(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Another function to concatenate bytes[]
            </summary>
            <param name="array1">
            </param>
            <param name="array2">
            </param>
            <param name="max">
            </param>
            <returns>New adition array</returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixMd5CryptTool.to64(System.Int32,System.Int32)">
            <summary>
            Base64-Encode integer value
            </summary>
            <param name="value"> The value to encode</param>
            <param name="length"> Desired length of the result</param>
            <returns>@return Base64 encoded value</returns>
        </member>
        <member name="M:Peach.Core.Transformers.Crypto.UnixMd5CryptTool.crypt(System.String,System.String,System.String)">
            <summary>
            Unix-like Crypt-MD5 function
            </summary>
            <param name="password">The user password</param>
            <param name="salt">The salt or the pepper of the password</param>
            <param name="magic">Extra characters to add</param>
            <returns>a human readable string</returns>
        </member>
        <member name="T:Peach.Core.AssertWriter">
            <summary>
            Helper class to add a debug listener so asserts get written to the console.
            </summary>
        </member>
        <member name="T:Peach.Core.NumberGenerator">
            <summary>
            A simple number generation class.
            </summary>
        </member>
        <member name="M:Peach.Core.NumberGenerator.GenerateBadNumbers(System.Int32,System.Int32)">
            <summary>
            Generate a list of numbers around size edge cases.
            </summary>
            <param name="size">The size (in bits) of the data</param>
            <param name="n">The +/- range number</param>
            <returns>Returns a list of all sizes to be used</returns>
        </member>
        <member name="T:Peach.Core.Utilities">
            <summary>
            Some utility methods that be usefull
            </summary>
        </member>
        <member name="M:Peach.Core.Utilities.SliceRange(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Compute the subrange resulting from diving a range into equal parts
            </summary>
            <param name="begin">Inclusive range begin</param>
            <param name="end">Inclusive range end</param>
            <param name="curSlice">The 1 based index of the current slice</param>
            <param name="numSlices">The total number of slices</param>
            <returns>Range of the current slice</returns>
        </member>
        <member name="T:Peach.Core.WebClientEx">
            <summary>
            Extention of WebClient that supports cookies
            </summary>
        </member>
        <member name="T:Peach.Core.ObjectCopier">
            <summary>
            Required for coping non-DataElements.
            </summary>
            <remarks>
            Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx
            Provides a method for performing a deep copy of an object.
            Binary Serialization is used to perform the copy.
            </remarks>
        </member>
        <member name="M:Peach.Core.ObjectCopier.Clone``1(``0)">
            <summary>
            Perform a deep Copy of the object.
            </summary>
            <typeparam name="T">The type of object being copied.</typeparam>
            <param name="source">The object instance to copy.</param>
            <returns>The copied object.</returns>
        </member>
        <member name="T:Peach.Core.Variant">
            <summary>
            Variant class emulates untyped scripting languages
            variables were typing can change as needed.  This class
            solves the problem of boxing internal types.  Instead
            explicit casts are used to access the value as needed.
            TODO: Investigate implicit casting as well.
            TODO: Investigate deligates for type -&gt; byte[] conversion.
            </summary>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.Int32">
            <summary>
            Access variant as an int value.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>int representation of value</returns>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.UInt32">
            <summary>
            Access variant as an int value.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>int representation of value</returns>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.String">
            <summary>
            Access variant as string value.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>string representation of value</returns>
        </member>
        <member name="M:Peach.Core.Variant.op_Explicit(Peach.Core.Variant)~System.Byte[]">
            <summary>
            Access variant as byte[] value.  This type is currently limited
            as neather int or string's are properly cast to byte[] since
            additional information is needed.
            TODO: Investigate using deligates to handle conversion.
            </summary>
            <param name="v">Variant to cast</param>
            <returns>byte[] representation of value</returns>
        </member>
        <member name="T:Peach.Core.Watcher">
            <summary>
            Watches the Peach Engine events.  This is how to
            add a UI or logging.
            </summary>
        </member>
        <member name="T:Peach.Core.Xml.Defaults">
            <summary>
            Process sample files to determin data types
            and set of default values.
            </summary>
        </member>
        <member name="M:Peach.Core.Xml.Defaults.ProcessFolder(System.String)">
            <summary>
            Process all files in folder as sample files.  We will
            use this information to guess data types and default
            values.
            </summary>
            <param name="folder">Folder to pull sample files from.</param>
        </member>
        <member name="M:Peach.Core.Xml.Defaults.ProcessFile(System.String)">
            <summary>
            Process a single file for sample data and data types.
            </summary>
            <param name="file">File to use as sample.</param>
        </member>
        <member name="M:Peach.Core.Xml.Defaults.GuessDataType(System.String)">
            <summary>
            Guess actual data type based on sample values.
            </summary>
            <param name="value">Value to guess about</param>
            <returns>Returns </returns>
        </member>
        <member name="T:Peach.Core.Xml.Element">
            <summary>
            Element Model
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Element.attributes">
            <summary>
            Key == Attribute.name, value == Attribute
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Element.relation">
            <summary>
            Rules for child elements if any.
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Element.defaultValues">
            <summary>
            Any known default values.
            </summary>
        </member>
        <member name="T:Peach.Core.Xml.DataType">
            <summary>
            Possible data types for elements and attributes.
            </summary>
        </member>
        <member name="T:Peach.Core.Xml.ElementRelationType">
            <summary>
            Element relation type
            </summary>
        </member>
        <member name="T:Peach.Core.Xml.ElementRelation">
            <summary>
            Capture an element relation from the DTD.
            </summary>
        </member>
        <member name="T:Peach.Core.Xml.Attribute">
            <summary>
            Attribute Model
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Attribute.name">
            <summary>
            Attribute name
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Attribute.type">
            <summary>
            Attribute type
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Attribute.dataType">
            <summary>
            Data type for attribute.
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Attribute.value">
            <summary>
            Attribute value if provided by DTD.
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Attribute.required">
            <summary>
            Is attribute required.
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Attribute.implied">
            <summary>
            Is attribute implied (optional)
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Attribute.enumValues">
            <summary>
            If AttributeType is enum, here are valid values.
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Attribute.defaultValues">
            <summary>
            Possible default values for attribute
            </summary>
        </member>
        <member name="M:Peach.Core.Xml.Entity.ResolveEntities(System.String)">
            <summary>
            Uses our list of defined entities to resolve any
            entity references inside of a string.
            </summary>
            <param name="data">String that may contain entities</param>
            <returns>Returns a string with all entities resolved.</returns>
        </member>
        <member name="T:Peach.Core.Xml.Generator">
            <summary>
            Generate XML documents based on Element definitions.
            </summary>
        </member>
        <member name="F:Peach.Core.Xml.Generator._GenerateXmlNode_Depth">
            <summary>
            Track depth to prevent infinit recurtion
            </summary>
        </member>
        <member name="M:Peach.Core.Xml.Generator.GenerateXmlDocument">
            <summary>
            Generate an XmlDocument based on the definition
            of the root Element provided to the constructor
            of this class.
            Each call to GenerateXmlDocument will return a
            different document.
            </summary>
            <returns>Returns XmlDocument generated from rootElement definition.</returns>
        </member>
        <member name="M:Peach.Core.Xml.Generator.GenerateXmlNode(Peach.Core.Xml.Element)">
            <summary>
            Generate an XmlNode based on an Element definition.
            Will also generate all attributes and child elements.
            </summary>
            <param name="element">Element definition to use</param>
            <returns>Returns XmlNode object</returns>
        </member>
        <member name="M:Peach.Core.Xml.Generator.GenerateXmlAttributes(Peach.Core.Xml.Element,System.Xml.XmlNode)">
            <summary>
            Generate the attributes for a new XmlNode based on
            the Element definition.
            </summary>
            <param name="element">Element definition</param>
            <param name="node">XmlNode to add attributes to</param>
        </member>
        <member name="T:Peach.Core.Xml.Parser">
            <summary>
            Abstract base class for all XML schema parsers (DTD, Schema, relaxedng, etc)
            </summary>
        </member>
        <member name="T:Peach.Core.Xml.ParserDtd">
            <summary>
            DTD Xml Schema parser.  Converts a DTD specification into
            an element constraint graph that can be used to generate XML.
            </summary>
        </member>
    </members>
</doc>
